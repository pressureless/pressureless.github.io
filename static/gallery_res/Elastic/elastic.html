<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
    <script>
MathJax = {
  loader: {
    load: ["[attrLabel]/attr-label.js"],
    paths: { attrLabel: "../resource" },
  },
  tex: { packages: { "[+]": ["attr-label"] },
   inlineMath: [['$', '$']]
   },
   options: {
    enableAssistiveMml: false
  },
};
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/dist/svg-arrow.css"/>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/dist/border.css" />
    <script src="../resource/d3.min.js"></script>
    <script src="../resource/svg.min.js"></script>
    <script type="text/javascript" src='../resource/paper.js'></script>
    <link rel="stylesheet" href="../resource/paper.css">
</head>
<script>
const iheartla_data = JSON.parse('{"equations":[{"name":"elastic", "parameters":[{"sym":"$E_r$", "type_info":{"type": "scalar"}, "desc":"the internal energy of the rods"},{"sym":"$q_g$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "desc":"point"},{"sym":"$q_h$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "desc":"point"},{"sym":"$m_g$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "desc":"the material vectors of $g$"},{"sym":"$m_h$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "desc":"the material vectors at $h$"},{"sym":"$\\\\angle$", "type_info":{"type": "function", "params":[{"type": "vector", "element":{"type": "scalar"}, "rows":"n"},{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}], "ret":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}}},{"sym":"$λ_{q,1}$", "type_info":{"type": "scalar"}, "desc":"the constraint weights for the position"},{"sym":"$λ_{q,2}$", "type_info":{"type": "scalar"}, "desc":"the constraint weights for the direction"},{"sym":"t", "type_info":{"type": "scalar"}, "desc":"offset"},{"sym":"$λ_{a,1}$", "type_info":{"type": "scalar"}, "desc":"weight"},{"sym":"$λ_{a,2}$", "type_info":{"type": "scalar"}, "desc":"weight"},{"sym":"q", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$q_a$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"m", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$m_a$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$δ^{(−)}$", "type_info":{"type": "scalar"}},{"sym":"$δ^{(+)}$", "type_info":{"type": "scalar"}},{"sym":"$β_q$", "type_info":{"type": "scalar"}, "desc":"barycentric coordinates "},{"sym":"$β^{(−)}$", "type_info":{"type": "scalar"}, "desc":"the barycentric coordinates of the notch bounds on their corresponding edges"},{"sym":"$β^{(+)}$", "type_info":{"type": "scalar"}, "desc":"the barycentric coordinates of the notch bounds on their corresponding edges"},{"sym":"μ", "type_info":{"type": "scalar"}, "desc":"a weighting parameter"},{"sym":"ε", "type_info":{"type": "scalar"}, "desc":"denoting how far $q$ is allowed to move past the end of the edge"}], "definition":[{"sym":"E", "type_info":{"type": "scalar"}, "desc":" the entire energy $E$ for the rod centerline points $x$  "}], "local_func":[], "dependence":[{"module":"connection", "syms":[{"sym":"$E_q$", "type_info":{"type": "scalar"}, "desc":" $E_q$ is the energy of the connection constraints "}], "initialization":["$q_g$","$q_h$","$m_g$","$m_h$","$\\\\angle$","$λ_{q,1}$","$λ_{q,2}$","t"]},{"module":"anchor", "syms":[{"sym":"$E_a$", "type_info":{"type": "scalar"}, "desc":" $E_a$ is the energy of the anchor constraints "}], "initialization":["$λ_{a,1}$","$λ_{a,2}$","q","$q_a$","m","$m_a$","$\\\\angle$"]},{"module":"notchlimit", "syms":[{"sym":"$E_n$", "type_info":{"type": "scalar"}, "desc":" $E_n$ is the energy of the notch-limit constraints "}], "initialization":["$δ^{(−)}$","$δ^{(+)}$","$β_q$","$β^{(−)}$","$β^{(+)}$"]},{"module":"penalty", "syms":[{"sym":"$E_p$", "type_info":{"type": "scalar"}, "desc":" $E_p$ is an additional notch penalty term that also serves to account for friction "}], "initialization":["μ","ε","$β_q$"]}], "source":"`$E_q$` from connection(`$q_g$`,`$q_h$`,`$m_g$`,`$m_h$`,`$\\\\angle$`,`$λ_{q,1}$`,`$λ_{q,2}$`,t)\\n`$E_a$` from anchor(`$λ_{a,1}$`,`$λ_{a,2}$`,q,`$q_a$`,m,`$m_a$`, `$\\\\angle$`)\\n`$E_n$` from notchlimit(`$δ^{(−)}$`,`$δ^{(+)}$`,`$β_q$`,`$β^{(−)}$`,`$β^{(+)}$`)\\n`$E_p$` from penalty(μ, ε, `$β_q$`)\\nE = `$E_r$` + `$E_q$` + `$E_a$` + `$E_n$` + `$E_p$`\\nwhere\\n`$E_r$` ∈ ℝ:the internal energy of the rods\\nwhere\\n`$q_g$` ∈ ℝ^n: point\\n`$q_h$` ∈ ℝ^n: point\\n`$m_g$` ∈ ℝ^n : the material vectors of $g$\\n`$m_h$` ∈ ℝ^n : the material vectors at $h$\\n`$\\\\angle$` ∈ ℝ^n, ℝ^n -> ℝ^n\\n`$λ_{q,1}$` ∈ ℝ: the constraint weights for the position\\n`$λ_{q,2}$` ∈ ℝ: the constraint weights for the direction\\nt ∈ ℝ : offset\\nwhere\\n`$λ_{a,1}$` ∈ ℝ: weight\\n`$λ_{a,2}$` ∈ ℝ: weight\\nq ∈ ℝ^n \\n`$q_a$` ∈ ℝ^n \\nm ∈ ℝ^n \\n`$m_a$` ∈ ℝ^n \\nwhere\\n`$δ^{(−)}$` ∈ ℝ\\n`$δ^{(+)}$` ∈ ℝ\\n`$β_q$` ∈ ℝ :  barycentric coordinates \\n`$β^{(−)}$` ∈ ℝ : the barycentric coordinates of the notch bounds on their corresponding edges\\n`$β^{(+)}$` ∈ ℝ : the barycentric coordinates of the notch bounds on their corresponding edges\\nwhere\\nμ ∈ ℝ: a weighting parameter\\nε ∈ ℝ: denoting how far $q$ is allowed to move past the end of the edge\\n" },{"name":"connection", "parameters":[{"sym":"$q_g$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "desc":"point"},{"sym":"$q_h$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "desc":"point"},{"sym":"$m_g$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "desc":"the material vectors of $g$"},{"sym":"$m_h$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "desc":"the material vectors at $h$"},{"sym":"$\\\\angle$", "type_info":{"type": "function", "params":[{"type": "vector", "element":{"type": "scalar"}, "rows":"n"},{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}], "ret":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}}},{"sym":"$λ_{q,1}$", "type_info":{"type": "scalar"}, "desc":"the constraint weights for the position"},{"sym":"$λ_{q,2}$", "type_info":{"type": "scalar"}, "desc":"the constraint weights for the direction"},{"sym":"t", "type_info":{"type": "scalar"}}], "definition":[{"sym":"$E_q$", "type_info":{"type": "scalar"}}], "local_func":[], "dependence":[], "source":"`$E_q$` = `$λ_{q,1}$`||`$q_g$`-`$q_h$`+t`$m_g$`||^2 + `$λ_{q,1}$`||`$q_h$`-`$q_g$`+t`$m_h$`||^2 + `$λ_{q,2}$`||`$\\\\angle$`(`$m_g$`,`$m_h$`)||^2 \\nwhere\\n`$q_g$` ∈ ℝ^n : point\\n`$q_h$` ∈ ℝ^n : point\\n`$m_g$` ∈ ℝ^n : the material vectors of $g$\\n`$m_h$` ∈ ℝ^n : the material vectors at $h$\\n`$\\\\angle$` ∈ ℝ^n, ℝ^n -> ℝ^n\\n`$λ_{q,1}$` ∈ ℝ : the constraint weights for the position\\n`$λ_{q,2}$` ∈ ℝ : the constraint weights for the direction\\nt ∈ ℝ\\n" },{"name":"anchor", "parameters":[{"sym":"$λ_{a,1}$", "type_info":{"type": "scalar"}, "desc":"weight"},{"sym":"$λ_{a,2}$", "type_info":{"type": "scalar"}, "desc":"weight"},{"sym":"q", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$q_a$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"m", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$m_a$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$\\\\angle$", "type_info":{"type": "function", "params":[{"type": "vector", "element":{"type": "scalar"}, "rows":"n"},{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}], "ret":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}}}], "definition":[{"sym":"$E_a$", "type_info":{"type": "scalar"}}], "local_func":[], "dependence":[], "source":"`$E_a$` = `$λ_{a,1}$`||q-`$q_a$`||^2 + `$λ_{a,2}$`||`$\\\\angle$`(m,`$m_a$`)||^2 \\nwhere\\n`$λ_{a,1}$` ∈ ℝ : weight\\n`$λ_{a,2}$` ∈ ℝ : weight\\nq ∈ ℝ^n \\n`$q_a$` ∈ ℝ^n \\nm ∈ ℝ^n \\n`$m_a$` ∈ ℝ^n \\n`$\\\\angle$` ∈ ℝ^n, ℝ^n -> ℝ^n\\n" },{"name":"notchlimit", "parameters":[{"sym":"$δ^{(−)}$", "type_info":{"type": "scalar"}},{"sym":"$δ^{(+)}$", "type_info":{"type": "scalar"}},{"sym":"$β_q$", "type_info":{"type": "scalar"}, "desc":"barycentric coordinates "},{"sym":"$β^{(−)}$", "type_info":{"type": "scalar"}, "desc":"the barycentric coordinates of the notch bounds on their corresponding edges"},{"sym":"$β^{(+)}$", "type_info":{"type": "scalar"}, "desc":"the barycentric coordinates of the notch bounds on their corresponding edges"}], "definition":[{"sym":"$E_n$", "type_info":{"type": "scalar"}, "desc":" The notch-limit constraint energy $E_n$  "}], "local_func":[], "dependence":[], "source":"`$E_n$` = `$δ^{(−)}$`(1/10 log((`$β_q$`-`$β^{(−)}$`)))^2 + `$δ^{(+)}$`(1/10 log((`$β^{(+)}$`-`$β_q$`)))^2\\nwhere\\n`$δ^{(−)}$` ∈ ℝ \\n`$δ^{(+)}$` ∈ ℝ\\n`$β_q$` ∈ ℝ :  barycentric coordinates \\n`$β^{(−)}$` ∈ ℝ : the barycentric coordinates of the notch bounds on their corresponding edges\\n`$β^{(+)}$` ∈ ℝ : the barycentric coordinates of the notch bounds on their corresponding edges\\n" },{"name":"penalty", "parameters":[{"sym":"μ", "type_info":{"type": "scalar"}, "desc":"a weighting parameter"},{"sym":"ε", "type_info":{"type": "scalar"}, "desc":"denoting how far $q$ is allowed to move past the end of the edge"},{"sym":"$β_q$", "type_info":{"type": "scalar"}, "desc":"barycentric coordinates "}], "definition":[{"sym":"$E_p$", "type_info":{"type": "scalar"}}], "local_func":[], "dependence":[], "source":"`$E_p$` = (μ log((ε + `$β_q$`)))^2 + (μ log((ε + 1 - `$β_q$`)))^2\\nwhere\\nμ ∈ ℝ : a weighting parameter\\nε ∈ ℝ : denoting how far $q$ is allowed to move past the end of the edge\\n`$β_q$` ∈ ℝ :  barycentric coordinates \\n" }], "context":["elastic","connection","anchor","notchlimit","penalty"] }');
const sym_data = JSON.parse('{"$E_r$":[{"desc":"the internal energy of the rods", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"HotPink"}],"$q_g$":[{"desc":"point", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"LightCoral"},{"desc":"point", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"connection", "is_defined":false, "used_equations":[], "color":"LightCoral"}],"$q_h$":[{"desc":"point", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"DarkRed"},{"desc":"point", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"connection", "is_defined":false, "used_equations":[], "color":"DarkRed"}],"$m_g$":[{"desc":"the material vectors of $g$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"Orange"},{"desc":"the material vectors of $g$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"connection", "is_defined":false, "used_equations":[], "color":"Orange"}],"$m_h$":[{"desc":"the material vectors at $h$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"Tomato"},{"desc":"the material vectors at $h$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"connection", "is_defined":false, "used_equations":[], "color":"Tomato"}],"$\\\\angle$":[{"desc":"None", "type_info":{"type": "function", "params":[{"type": "vector", "element":{"type": "scalar"}, "rows":"n"},{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}], "ret":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"red"},{"desc":"None", "type_info":{"type": "function", "params":[{"type": "vector", "element":{"type": "scalar"}, "rows":"n"},{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}], "ret":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}}, "def_module":"connection", "is_defined":false, "used_equations":[], "color":"red"},{"desc":"None", "type_info":{"type": "function", "params":[{"type": "vector", "element":{"type": "scalar"}, "rows":"n"},{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}], "ret":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}}, "def_module":"anchor", "is_defined":false, "used_equations":[], "color":"red"}],"$λ_{q,1}$":[{"desc":"the constraint weights for the position", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"HotPink"},{"desc":"the constraint weights for the position", "type_info":{"type": "scalar"}, "def_module":"connection", "is_defined":false, "used_equations":[], "color":"HotPink"}],"$λ_{q,2}$":[{"desc":"the constraint weights for the direction", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"Gold"},{"desc":"the constraint weights for the direction", "type_info":{"type": "scalar"}, "def_module":"connection", "is_defined":false, "used_equations":[], "color":"Gold"}],"t":[{"desc":"offset", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"DeepSkyBlue"},{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"connection", "is_defined":false, "used_equations":[], "color":"DeepSkyBlue"}],"$λ_{a,1}$":[{"desc":"weight", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"DarkRed"},{"desc":"weight", "type_info":{"type": "scalar"}, "def_module":"anchor", "is_defined":false, "used_equations":[], "color":"DarkRed"}],"$λ_{a,2}$":[{"desc":"weight", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"YellowGreen"},{"desc":"weight", "type_info":{"type": "scalar"}, "def_module":"anchor", "is_defined":false, "used_equations":[], "color":"YellowGreen"}],"q":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"Orange"},{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"anchor", "is_defined":false, "used_equations":[], "color":"Orange"}],"$q_a$":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"Tomato"},{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"anchor", "is_defined":false, "used_equations":[], "color":"Tomato"}],"m":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"HotPink"},{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"anchor", "is_defined":false, "used_equations":[], "color":"HotPink"}],"$m_a$":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"Gold"},{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"anchor", "is_defined":false, "used_equations":[], "color":"Gold"}],"$δ^{(−)}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"DeepSkyBlue"},{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"notchlimit", "is_defined":false, "used_equations":[], "color":"DeepSkyBlue"}],"$δ^{(+)}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"Orange"},{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"notchlimit", "is_defined":false, "used_equations":[], "color":"Orange"}],"$β_q$":[{"desc":"barycentric coordinates ", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"YellowGreen"},{"desc":"barycentric coordinates ", "type_info":{"type": "scalar"}, "def_module":"notchlimit", "is_defined":false, "used_equations":[], "color":"YellowGreen"},{"desc":"barycentric coordinates ", "type_info":{"type": "scalar"}, "def_module":"penalty", "is_defined":false, "used_equations":[], "color":"YellowGreen"}],"$β^{(−)}$":[{"desc":"the barycentric coordinates of the notch bounds on their corresponding edges", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"Tomato"},{"desc":"the barycentric coordinates of the notch bounds on their corresponding edges", "type_info":{"type": "scalar"}, "def_module":"notchlimit", "is_defined":false, "used_equations":[], "color":"Tomato"}],"$β^{(+)}$":[{"desc":"the barycentric coordinates of the notch bounds on their corresponding edges", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"Gold"},{"desc":"the barycentric coordinates of the notch bounds on their corresponding edges", "type_info":{"type": "scalar"}, "def_module":"notchlimit", "is_defined":false, "used_equations":[], "color":"Gold"}],"μ":[{"desc":"a weighting parameter", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"DarkRed"},{"desc":"a weighting parameter", "type_info":{"type": "scalar"}, "def_module":"penalty", "is_defined":false, "used_equations":[], "color":"DarkRed"}],"ε":[{"desc":"denoting how far $q$ is allowed to move past the end of the edge", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[], "color":"red"},{"desc":"denoting how far $q$ is allowed to move past the end of the edge", "type_info":{"type": "scalar"}, "def_module":"penalty", "is_defined":false, "used_equations":[], "color":"red"}],"E":[{"desc":" the entire energy $E$ for the rod centerline points $x$  ", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":true, "used_equations":[], "color":"LightCoral"}],"$E_q$":[{"desc":" $E_q$ is the energy of the connection constraints ", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":true, "used_equations":[], "color":"YellowGreen"},{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"connection", "is_defined":true, "used_equations":"elastic", "color":"YellowGreen"}],"$E_a$":[{"desc":" $E_a$ is the energy of the anchor constraints ", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":true, "used_equations":[], "color":"DeepSkyBlue"},{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"anchor", "is_defined":true, "used_equations":"elastic", "color":"DeepSkyBlue"}],"$E_n$":[{"desc":" $E_n$ is the energy of the notch-limit constraints ", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":true, "used_equations":[], "color":"red"},{"desc":" The notch-limit constraint energy $E_n$  ", "type_info":{"type": "scalar"}, "def_module":"notchlimit", "is_defined":true, "used_equations":"elastic", "color":"red"}],"$E_p$":[{"desc":" $E_p$ is an additional notch penalty term that also serves to account for friction ", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":true, "used_equations":[], "color":"Gold"},{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"penalty", "is_defined":true, "used_equations":"elastic", "color":"Gold"}]}');
window.onload = onLoad;
function reportWindowSize() {
  var arrows = document.querySelectorAll(".arrow");
  if (arrows) {
    for (var i = arrows.length - 1; i >= 0; i--) {
      var arrow = arrows[i];
      var body = document.querySelector("body");
      var style = window.getComputedStyle(body);
      var curOffset = parseInt(style.marginLeft, 10)
      var oldOffset = arrow.getAttribute('offset');
      arrow.setAttribute('offset', curOffset);
      // console.log(`oldOffset:${oldOffset}, curOffset:${curOffset}`);
      var arrowStyle = window.getComputedStyle(arrow); 
      var arrowOffset = parseInt(document.querySelector(".arrow").style.marginLeft, 10)
      arrow.style.marginLeft = `${arrowOffset+curOffset-oldOffset}px`;
      var newWidth = parseInt(style.width, 10) + parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
      arrow.style.width = `${newWidth}px`;
      arrow.style.height = style.height; 
      // console.log(`arrow.style.width:${arrow.style.width}, arrow.style.height:${arrow.style.height}`)
    }
  }
  adjsutGlossaryBtn();
}
window.onresize = reportWindowSize;
document.addEventListener("click", function(evt){
    resetState();
});

</script>
<body>
<div id="glossary" class="glossary"></div><br>
<div class='title'>On Elastic Geodesic Grids and Their Planar to Spatial Deployment</div><div class='author'>STEFAN PILLWEIN, TU Wien</div><div class='author'>KURT LEIMER, TU Wien</div><div class='author'>MICHAEL BIRSAK, KAUST</div><div class='author'>PRZEMYSLAW MUSIALSKI, NJIT and TU Wien</div><ul><li><a href='#physical-simulation'>5&nbsp;PHYSICAL SIMULATION</a></li></ul>
<h1 id='physical-simulation'>5&nbsp;PHYSICAL SIMULATION</h1><div class='context' id='context-elastic-0' context='elastic'>
<p>To simulate the physical behavior of the deployed grid, we use a simulation based on discrete elastic rods [Bergou et al. 2010] and build upon the solution of [Vekhter et al. 2019]. We refer the reader to those papers for the details. Note, that the associated material frames of the rods do not need to be isotropic, which allows us also to model the exact cross sections of lamellas with a ratio of 1 : 10.</p>
<p>A central aspect of the kinematics of elastic geodesic grids is the ability of grid members to slide at connections, denoted in the following as ${\proselabel{elastic}{{q}}}$. In general, they do not coincide with the vertices of the discretized grid members. To handle them, we introduce <span sym='β_q' context='elastic'>  barycentric coordinates ${\prosedeflabel{elastic}{{β_q}}}$ to describe the location of a connection on a rod-edge  </span>. We also take the physical thickness ${\proselabel{elastic}{{t}}}$ of the lamellas into account, which is modeled by an offset between the members $g$ and $h$ at each connection. Hence, a connection ${\proselabel{elastic}{{q}}}$ consists of two points ${\proselabel{elastic}{{q_g}}}$ and ${\proselabel{elastic}{{q_h}}}$ with an offset ${\proselabel{elastic}{{t}}}$. Apart from sliding, members are allowed to rotate around connections about an axis that is parallel to the cross product of the edges ${\proselabel{elastic}{{q_g}}}$ and ${\proselabel{elastic}{{q_h}}}$ lie on.</p>
<p>Simulation. Our aim is to find the equilibrium state of the given elastic grid, which corresponds to an optimization problem of minimizing the energy functional</p>
<p>
        <div class='equation' code_block="elastic">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'E', 'elastic', 'def', false, '')", "id":"elastic-E", "sym":"E", "func":"elastic",  "localFunc":"", "type":"def", "case":"equation"} }{ {\mathit{E}} } & = \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_r$', 'elastic', 'use', false, '')", "id":"elastic-$E_r$", "sym":"$E_r$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {E_r} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_q$', 'elastic', 'use', false, '')", "id":"elastic-$E_q$", "sym":"$E_q$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {E_q} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_a$', 'elastic', 'use', false, '')", "id":"elastic-$E_a$", "sym":"$E_a$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {E_a} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_n$', 'elastic', 'use', false, '')", "id":"elastic-$E_n$", "sym":"$E_n$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {E_n} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_p$', 'elastic', 'use', false, '')", "id":"elastic-$E_p$", "sym":"$E_p$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {E_p} }\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'elastic', ['$E_q$', '$E_p$', '$E_r$', '$E_n$', '$E_a$', 'E'], false, []);"} }{}
\end{align*}
\notag$$</div>
        <br />
where <span sym='E_r' context='elastic'>  ${\prosedeflabel{elastic}{{E_r}}}$ is the internal energy of the rods  </span>, <span sym='E_q' context='elastic'>  ${\prosedeflabel{elastic}{{E_q}}}$ is the energy of the connection constraints  </span>, <span sym='E_a' context='elastic'>  ${\prosedeflabel{elastic}{{E_a}}}$ is the energy of the anchor constraints  </span>, <span sym='E_n' context='elastic'>  ${\prosedeflabel{elastic}{{E_n}}}$ is the energy of the notch-limit constraints  </span>, and <span sym='E_p' context='elastic'>  ${\prosedeflabel{elastic}{{E_p}}}$ is an additional notch penalty term that also serves to account for friction  </span>. We perform the simulation by minimizing <span sym='E' context='elastic'>  the entire energy ${\prosedeflabel{elastic}{{E}}}$ for the rod centerline points $x$   </span>using a Gauss-Newton method in a similar fashion as proposed by Vekhter et al. [2019]. In Section 6.2 we perform an empirical evaluation of the accuracy of the simulation by comparing it to laser-scans of the makes.</p>
<figure>
<img src="./img/img10.png" alt="Trulli" style="width:100%" class = "center">
<figcaption align = "center">Fig. 10. The influence of anchors and notches on the example Archway. Left: Anchors at the corners are not sufficient to push the grid into the right configuration. Center: Deployed state without notches, local buckling and irregularities in smoothness can be observed. Right: Notches relax the structure to a more natural, lower energy shape (cf. Sections 4.5 and 4.6).</figcaption> 
</figure>
<p>For the sake of readability, we will define the constraint energy terms only for a single constraint each. Er is the sum of stretching, bending and twisting energies of each individual rod. As a full explanation of the DER formulation is out of scope for this paper, we refer the reader to the work of [Bergou et al. 2010] for a detailed description of these terms.</p>
</div><div class='context' id='context-connection-0' context='connection'>
<p>The connection constraint energy ${\proselabel{connection}{{E_q}}}$ is given by<br />

        <div class='equation' code_block="connection">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_q$', 'connection', 'def', false, '')", "id":"connection-$E_q$", "sym":"$E_q$", "func":"connection",  "localFunc":"", "type":"def", "case":"equation"} }{ {E_q} } & = \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$λ_{q,1}$', 'connection', 'use', false, '')", "id":"connection-$λ_{q,1}$", "sym":"$λ_{q,1}$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {λ_{q,1}} }\left\|\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$q_g$', 'connection', 'use', false, '')", "id":"connection-$q_g$", "sym":"$q_g$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {q_g} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$q_h$', 'connection', 'use', false, '')", "id":"connection-$q_h$", "sym":"$q_h$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {q_h} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't', 'connection', 'use', false, '')", "id":"connection-t", "sym":"t", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{t}} }\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$m_g$', 'connection', 'use', false, '')", "id":"connection-$m_g$", "sym":"$m_g$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {m_g} }\right\|_2^{2} + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$λ_{q,1}$', 'connection', 'use', false, '')", "id":"connection-$λ_{q,1}$", "sym":"$λ_{q,1}$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {λ_{q,1}} }\left\|\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$q_h$', 'connection', 'use', false, '')", "id":"connection-$q_h$", "sym":"$q_h$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {q_h} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$q_g$', 'connection', 'use', false, '')", "id":"connection-$q_g$", "sym":"$q_g$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {q_g} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't', 'connection', 'use', false, '')", "id":"connection-t", "sym":"t", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{t}} }\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$m_h$', 'connection', 'use', false, '')", "id":"connection-$m_h$", "sym":"$m_h$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {m_h} }\right\|_2^{2} + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$λ_{q,2}$', 'connection', 'use', false, '')", "id":"connection-$λ_{q,2}$", "sym":"$λ_{q,2}$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {λ_{q,2}} }\left\|\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$\\\\angle$', 'connection', 'use', false, '')", "id":"connection-$\\\\angle$", "sym":"$\\\\angle$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {\angle} }\left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$m_g$', 'connection', 'use', false, '')", "id":"connection-$m_g$", "sym":"$m_g$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {m_g} },\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$m_h$', 'connection', 'use', false, '')", "id":"connection-$m_h$", "sym":"$m_h$", "func":"connection",  "localFunc":"", "type":"use", "case":"equation"} }{ {m_h} } \right)\right\|_2^{2}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'connection', ['$q_g$', '$\\\\angle$', '$m_h$', '$m_g$', '$λ_{q,1}$', '$q_h$', '$λ_{q,2}$', 't', '$E_q$'], false, []);"} }{}
\end{align*}
\notag$$</div>
        <br />
with <span sym='m_g;m_h' context='connection'>  ${\prosedeflabel{connection}{{m_g}}}$ and ${\prosedeflabel{connection}{{m_h}}}$ denoting the material vectors of $g$ and $h$ at $q$ respectively  </span>. The term $tm$ accounts for the thickness of the rods, while <span sym='λ_{q,1};λ_{q,2}' context='connection'>  ${\prosedeflabel{connection}{{λ_{q,1}}}}$ and ${\prosedeflabel{connection}{{λ_{q,2}}}}$ are the constraint weights for the position and direction terms  </span>.</p>
</div><div class='context' id='context-anchor-0' context='anchor'>
<p>The anchor constraint energy ${\proselabel{anchor}{{E_a}}}$ ensures that both the position ${\proselabel{anchor}{{q}}}$ and material vector ${\proselabel{anchor}{{m}}}$ of the given connection do not deviate from the position ${\proselabel{anchor}{{q_a}}}$ and material vector ${\proselabel{anchor}{{m_a}}}$ of the corresponding anchor. It is given by</p>
<p>
        <div class='equation' code_block="anchor">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_a$', 'anchor', 'def', false, '')", "id":"anchor-$E_a$", "sym":"$E_a$", "func":"anchor",  "localFunc":"", "type":"def", "case":"equation"} }{ {E_a} } & = \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$λ_{a,1}$', 'anchor', 'use', false, '')", "id":"anchor-$λ_{a,1}$", "sym":"$λ_{a,1}$", "func":"anchor",  "localFunc":"", "type":"use", "case":"equation"} }{ {λ_{a,1}} }\left\|\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'q', 'anchor', 'use', false, '')", "id":"anchor-q", "sym":"q", "func":"anchor",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{q}} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$q_a$', 'anchor', 'use', false, '')", "id":"anchor-$q_a$", "sym":"$q_a$", "func":"anchor",  "localFunc":"", "type":"use", "case":"equation"} }{ {q_a} }\right\|_2^{2} + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$λ_{a,2}$', 'anchor', 'use', false, '')", "id":"anchor-$λ_{a,2}$", "sym":"$λ_{a,2}$", "func":"anchor",  "localFunc":"", "type":"use", "case":"equation"} }{ {λ_{a,2}} }\left\|\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$\\\\angle$', 'anchor', 'use', false, '')", "id":"anchor-$\\\\angle$", "sym":"$\\\\angle$", "func":"anchor",  "localFunc":"", "type":"use", "case":"equation"} }{ {\angle} }\left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'm', 'anchor', 'use', false, '')", "id":"anchor-m", "sym":"m", "func":"anchor",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{m}} },\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$m_a$', 'anchor', 'use', false, '')", "id":"anchor-$m_a$", "sym":"$m_a$", "func":"anchor",  "localFunc":"", "type":"use", "case":"equation"} }{ {m_a} } \right)\right\|_2^{2}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'anchor', ['q', '$\\\\angle$', '$λ_{a,2}$', '$m_a$', '$λ_{a,1}$', 'm', '$q_a$', '$E_a$'], false, []);"} }{}
\end{align*}
\notag$$</div>
        </p>
<p>with <span sym='λ_{a,1};λ_{a,2}' context='anchor'>  ${\prosedeflabel{anchor}{{λ_{a,1}}}}$ and ${\prosedeflabel{anchor}{{λ_{a,2}}}}$ as weights  </span>. This constraint applies to the grid corners and anchors.</p>
</div><div class='context' id='context-notchlimit-0' context='notchlimit'>
<p><span sym='E_n' context='notchlimit'>  The notch-limit constraint energy ${\prosedeflabel{notchlimit}{{E_n}}}$   </span>ensures that the connection point remains within the bounds of the notch. They are specified by the notch length l and the sliding direction (cf. Section 4.5):</p>
<p>
        <div class='equation' code_block="notchlimit">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_n$', 'notchlimit', 'def', false, '')", "id":"notchlimit-$E_n$", "sym":"$E_n$", "func":"notchlimit",  "localFunc":"", "type":"def", "case":"equation"} }{ {E_n} } & = \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$δ^{(−)}$', 'notchlimit', 'use', false, '')", "id":"notchlimit-$δ^{(−)}$", "sym":"$δ^{(−)}$", "func":"notchlimit",  "localFunc":"", "type":"use", "case":"equation"} }{ {δ^{(−)}} }{\left( \frac{1}{10} \log{ \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β_q$', 'notchlimit', 'use', false, '')", "id":"notchlimit-$β_q$", "sym":"$β_q$", "func":"notchlimit",  "localFunc":"", "type":"use", "case":"equation"} }{ {β_q} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β^{(−)}$', 'notchlimit', 'use', false, '')", "id":"notchlimit-$β^{(−)}$", "sym":"$β^{(−)}$", "func":"notchlimit",  "localFunc":"", "type":"use", "case":"equation"} }{ {β^{(−)}} } \right) } \right)}^{2} + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$δ^{(+)}$', 'notchlimit', 'use', false, '')", "id":"notchlimit-$δ^{(+)}$", "sym":"$δ^{(+)}$", "func":"notchlimit",  "localFunc":"", "type":"use", "case":"equation"} }{ {δ^{(+)}} }{\left( \frac{1}{10} \log{ \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β^{(+)}$', 'notchlimit', 'use', false, '')", "id":"notchlimit-$β^{(+)}$", "sym":"$β^{(+)}$", "func":"notchlimit",  "localFunc":"", "type":"use", "case":"equation"} }{ {β^{(+)}} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β_q$', 'notchlimit', 'use', false, '')", "id":"notchlimit-$β_q$", "sym":"$β_q$", "func":"notchlimit",  "localFunc":"", "type":"use", "case":"equation"} }{ {β_q} } \right) } \right)}^{2}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'notchlimit', ['$δ^{(+)}$', '$β_q$', '$β^{(+)}$', '$β^{(−)}$', '$δ^{(−)}$', '$E_n$'], false, []);"} }{}
\end{align*}
\notag$$</div>
        </p>
<p>with <span sym='β^{(−)};β^{(+)}' context='notchlimit'>  ${\prosedeflabel{notchlimit}{{β^{(−)}}}}$ and ${\prosedeflabel{notchlimit}{{β^{(+)}}}}$ denoting the barycentric coordinates of the notch bounds on their corresponding edges  </span>. The term is only active when the connection lies on the same rod-edge as one of the notch bounds, so ${\proselabel{notchlimit}{{δ^{(−)}}}} = 1$ or ${\proselabel{notchlimit}{{δ^{(+)}}}} = 1$ when the connection lies on one of these edges, and 0 otherwise.</p>
</div><div class='context' id='context-penalty-0' context='penalty'>
<p>The additional notch penalty term ${\proselabel{penalty}{{E_p}}}$ controls the movement of a connection q between two adjacent edges. If $q$ switches edges, it needs to be reprojected to the neighboring edge at the next iteration of the simulation. Within an iteration, ${\proselabel{penalty}{{E_p}}}$ prevents $q$ from moving too far beyond the end of the current edge:</p>
<p>
        <div class='equation' code_block="penalty">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_p$', 'penalty', 'def', false, '')", "id":"penalty-$E_p$", "sym":"$E_p$", "func":"penalty",  "localFunc":"", "type":"def", "case":"equation"} }{ {E_p} } & = {\left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'μ', 'penalty', 'use', false, '')", "id":"penalty-μ", "sym":"μ", "func":"penalty",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{μ}} } \log{ \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'ε', 'penalty', 'use', false, '')", "id":"penalty-ε", "sym":"ε", "func":"penalty",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{ε}} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β_q$', 'penalty', 'use', false, '')", "id":"penalty-$β_q$", "sym":"$β_q$", "func":"penalty",  "localFunc":"", "type":"use", "case":"equation"} }{ {β_q} } \right) } \right)}^{2} + {\left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'μ', 'penalty', 'use', false, '')", "id":"penalty-μ", "sym":"μ", "func":"penalty",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{μ}} } \log{ \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'ε', 'penalty', 'use', false, '')", "id":"penalty-ε", "sym":"ε", "func":"penalty",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{ε}} } + 1 - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β_q$', 'penalty', 'use', false, '')", "id":"penalty-$β_q$", "sym":"$β_q$", "func":"penalty",  "localFunc":"", "type":"use", "case":"equation"} }{ {β_q} } \right) } \right)}^{2}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'penalty', ['$β_q$', 'ε', 'μ', '$E_p$'], false, []);"} }{}
\end{align*}
\notag$$</div>
        <br />
with <span sym='ε' context='penalty'>  ${\prosedeflabel{penalty}{{ε}}}$ denoting how far $q$ is allowed to move past the end of the edge  </span> and <span sym='μ' context='penalty'>  ${\prosedeflabel{penalty}{{μ}}}$ acting as a weighting parameter  </span>(we choose ${\proselabel{penalty}{{ε}}} = 0.0001$, ${\proselabel{penalty}{{μ}}} = 0.1$).</p>
<figure>
<img src="./img/img11.png" alt="Trulli" style="width:100%" class = "center">
<figcaption align = "center">Fig. 11. The effect of the weighting parameter ${\proselabel{penalty}{{μ}}}$ in ${\proselabel{penalty}{{E_p}}}$ (from left to right): surface shaded with K and geodesics; ${\proselabel{penalty}{{μ}}} = 0.01$, rods slide onto geodesics; ${\proselabel{penalty}{{μ}}} = 0.1$, sliding in high $K$ areas reduced (our setting); ${\proselabel{penalty}{{μ}}} = 1$, sliding is heavily reduced. Refer to Section 7.3 for a further discussion on ${\proselabel{penalty}{{μ}}}$.</figcaption> 
</figure>

<p>Since ${\proselabel{penalty}{{E_p}}}$ is not 0 even inside the edge, it penalizes very small sliding movements that would otherwise accumulate over many iterations. In other words, ${\proselabel{penalty}{{E_p}}}$ creates a pseudo-frictional effect, which is controlled by ${\proselabel{penalty}{{μ}}}$. In a physical grid, friction creates a force acting against the sliding movement of a connection. If the driving force of the movement and the frictional force counterbalance, the movement stops. This situation has an analogy in our grids. A connection stops moving inside a notch if</p>
<p>$$\frac{\partial E_q }{\partial {\proselabel{penalty}{{β_q}}} } + \frac{\partial {\proselabel{penalty}{{E_p}}} }{\partial {\proselabel{penalty}{{β_q}}} } = 0 \tag{1}\label{1}$$</p>
<p>is fulfilled. Figure 11 depicts the effects of different values for ${\proselabel{penalty}{{μ}}}$.</p>
<div class="references"></div></div>
</body>
</html>