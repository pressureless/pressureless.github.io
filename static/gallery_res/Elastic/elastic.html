<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
    <script>
MathJax = {
  loader: {
    load: ["[attrLabel]/attr-label.js"],
    paths: { attrLabel: "../resource" },
  },
  tex: { packages: { "[+]": ["attr-label"] },
   inlineMath: [['$', '$']]
   },
   options: {
    enableAssistiveMml: false
  },
};
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/dist/svg-arrow.css"/>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/dist/border.css" />
    <script src="../resource/d3.min.js"></script>
    <script src="../resource/svg.min.js"></script>
    <script type="text/javascript" src='../resource/paper.js'></script>
    <link rel="stylesheet" href="../resource/paper.css">
</head>
<script>
const iheartla_data = JSON.parse('{"equations":[{"name":"elastic", "parameters":[{"sym":"$E_r$", "type_info":{"type": "scalar"}},{"sym":"$q_g$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$q_h$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$m_g$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$m_h$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$\\\\angle$", "type_info":{"type": "function", "params":[{"type": "vector", "element":{"type": "scalar"}, "rows":"n"},{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}], "ret":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}}},{"sym":"$λ_{q,1}$", "type_info":{"type": "scalar"}},{"sym":"$λ_{q,2}$", "type_info":{"type": "scalar"}},{"sym":"t", "type_info":{"type": "scalar"}},{"sym":"$λ_{a,1}$", "type_info":{"type": "scalar"}},{"sym":"$λ_{a,2}$", "type_info":{"type": "scalar"}},{"sym":"q", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$q_a$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"m", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$m_a$", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}},{"sym":"$δ^{(−)}$", "type_info":{"type": "scalar"}},{"sym":"$δ^{(+)}$", "type_info":{"type": "scalar"}},{"sym":"$β_q$", "type_info":{"type": "scalar"}},{"sym":"$β^{(−)}$", "type_info":{"type": "scalar"}},{"sym":"$β^{(+)}$", "type_info":{"type": "scalar"}},{"sym":"μ", "type_info":{"type": "scalar"}},{"sym":"ε", "type_info":{"type": "scalar"}}], "definition":[{"sym":"E", "type_info":{"type": "scalar"}},{"sym":"$E_q$", "type_info":{"type": "scalar"}},{"sym":"$E_a$", "type_info":{"type": "scalar"}},{"sym":"$E_n$", "type_info":{"type": "scalar"}},{"sym":"$E_p$", "type_info":{"type": "scalar"}}], "local_func":[], "source":"E = `$E_r$` + `$E_q$` + `$E_a$` + `$E_n$` + `$E_p$`\\nwhere\\n`$E_r$` ∈ ℝ\\n\\n`$E_q$` = `$λ_{q,1}$`||`$q_g$`-`$q_h$`+t`$m_g$`||^2 + `$λ_{q,1}$`||`$q_h$`-`$q_g$`+t`$m_h$`||^2 + `$λ_{q,2}$`||`$\\\\angle$`(`$m_g$`,`$m_h$`)||^2 \\nwhere\\n`$q_g$` ∈ ℝ^n\\n`$q_h$` ∈ ℝ^n\\n`$m_g$` ∈ ℝ^n \\n`$m_h$` ∈ ℝ^n \\n`$\\\\angle$` ∈ ℝ^n, ℝ^n -> ℝ^n\\n`$λ_{q,1}$` ∈ ℝ\\n`$λ_{q,2}$` ∈ ℝ\\nt ∈ ℝ\\n\\n`$E_a$` = `$λ_{a,1}$`||q-`$q_a$`||^2 + `$λ_{a,2}$`||`$\\\\angle$`(m,`$m_a$`)||^2 \\nwhere\\n`$λ_{a,1}$` ∈ ℝ\\n`$λ_{a,2}$` ∈ ℝ\\nq ∈ ℝ^n \\n`$q_a$` ∈ ℝ^n \\nm ∈ ℝ^n \\n`$m_a$` ∈ ℝ^n \\n\\n`$E_n$` = `$δ^{(−)}$`(1/10 log((`$β_q$`-`$β^{(−)}$`)))^2 + `$δ^{(+)}$`(1/10 log((`$β^{(+)}$`-`$β_q$`)))^2\\nwhere\\n`$δ^{(−)}$` ∈ ℝ\\n`$δ^{(+)}$` ∈ ℝ\\n`$β_q$` ∈ ℝ\\n`$β^{(−)}$` ∈ ℝ\\n`$β^{(+)}$` ∈ ℝ\\n\\n`$E_p$` = (μ log((ε + `$β_q$`)))^2 + (μ log((ε + 1 - `$β_q$`)))^2\\nwhere\\nμ ∈ ℝ\\nε ∈ ℝ\\n" }] }');
const sym_data = JSON.parse('{"$E_r$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$q_g$":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$q_h$":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$m_g$":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$m_h$":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$\\\\angle$":[{"desc":"None", "type_info":{"type": "function", "params":[{"type": "vector", "element":{"type": "scalar"}, "rows":"n"},{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}], "ret":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$λ_{q,1}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$λ_{q,2}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"t":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$λ_{a,1}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$λ_{a,2}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"q":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$q_a$":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"m":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$m_a$":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"n"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$δ^{(−)}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$δ^{(+)}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$β_q$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$β^{(−)}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"$β^{(+)}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"μ":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"ε":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":false, "used_equations":[]}],"E":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":true, "used_equations":[]}],"$E_q$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":true, "used_equations":[]}],"$E_a$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":true, "used_equations":[]}],"$E_n$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":true, "used_equations":[]}],"$E_p$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"elastic", "is_defined":true, "used_equations":[]}]}');
window.onload = onLoad;
function reportWindowSize() {
  var arrows = document.querySelectorAll(".arrow");
  if (arrows) {
    for (var i = arrows.length - 1; i >= 0; i--) {
      var arrow = arrows[i];
      var body = document.querySelector("body");
      var style = window.getComputedStyle(body);
      var curOffset = parseInt(style.marginLeft, 10)
      var oldOffset = arrow.getAttribute('offset');
      arrow.setAttribute('offset', curOffset);
      // console.log(`oldOffset:${oldOffset}, curOffset:${curOffset}`);
      var arrowStyle = window.getComputedStyle(arrow); 
      var arrowOffset = parseInt(document.querySelector(".arrow").style.marginLeft, 10)
      arrow.style.marginLeft = `${arrowOffset+curOffset-oldOffset}px`;
      var newWidth = parseInt(style.width, 10) + parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
      arrow.style.width = `${newWidth}px`;
      arrow.style.height = style.height; 
      // console.log(`arrow.style.width:${arrow.style.width}, arrow.style.height:${arrow.style.height}`)
    }
  }
  adjsutGlossaryBtn();
}
window.onresize = reportWindowSize;
document.addEventListener("click", function(evt){
    resetState();
});

</script>
<body>
<img src="../resource/glossary.png" id="glossary" class="glossary" alt="glossary" width="22" height="28"><br>
<ul><li><a href='#physical-simulation'>1&nbsp;PHYSICAL SIMULATION</a></li></ul>
<h1 id='physical-simulation'>1&nbsp;PHYSICAL SIMULATION</h1><p>To simulate the physical behavior of the deployed grid, we use a simulation based on discrete elastic rods [Bergou et al. 2010] and build upon the solution of [Vekhter et al. 2019]. We refer the reader to those papers for the details. Note, that the associated material frames of the rods do not need to be isotropic, which allows us also to model the exact cross sections of lamellas with a ratio of 1 : 10.</p>
<p>A central aspect of the kinematics of elastic geodesic grids is the ability of grid members to slide at connections, denoted in the following as ${\proselabel{elastic}{{q}}}$. In general, they do not coincide with the vertices of the discretized grid members. To handle them, we introduce <span sym='β_q' context='elastic'>  barycentric coordinates ${\prosedeflabel{elastic}{{β_q}}}$ to describe the location of a connection on a rod-edge  </span>. We also take the physical thickness ${\proselabel{elastic}{{t}}}$ of the lamellas into account, which is modeled by an offset between the members $g$ and $h$ at each connection. Hence, a connection ${\proselabel{elastic}{{q}}}$ consists of two points ${\proselabel{elastic}{{q_g}}}$ and ${\proselabel{elastic}{{q_h}}}$ with an offset ${\proselabel{elastic}{{t}}}$. Apart from sliding, members are allowed to rotate around connections about an axis that is parallel to the cross product of the edges ${\proselabel{elastic}{{q_g}}}$ and ${\proselabel{elastic}{{q_h}}}$ lie on.</p>
<p>Simulation. Our aim is to find the equilibrium state of the given elastic grid, which corresponds to an optimization problem of minimizing the energy functional</p>
<p>
        <div class='equation' code_block="elastic">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'E', 'elastic', 'def', false, '')", "id":"elastic-E", "sym":"E", "func":"elastic",  "localFunc":"", "type":"def", "case":"equation"} }{ {\mathit{E}} } & = \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_r$', 'elastic', 'use', false, '')", "id":"elastic-$E_r$", "sym":"$E_r$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {E_r} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_q$', 'elastic', 'use', false, '')", "id":"elastic-$E_q$", "sym":"$E_q$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {E_q} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_a$', 'elastic', 'use', false, '')", "id":"elastic-$E_a$", "sym":"$E_a$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {E_a} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_n$', 'elastic', 'use', false, '')", "id":"elastic-$E_n$", "sym":"$E_n$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {E_n} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_p$', 'elastic', 'use', false, '')", "id":"elastic-$E_p$", "sym":"$E_p$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {E_p} }\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'elastic', ['$E_n$', '$E_r$', '$E_a$', '$E_q$', '$E_p$', 'E'], false, []);"} }{}
\end{align*}
\tag{1}\label{1}$$</div>
        <br />
where <span sym='E_r' context='elastic'>  ${\prosedeflabel{elastic}{{E_r}}}$ is the internal energy of the rods  </span>, <span sym='E_q' context='elastic'>  ${\prosedeflabel{elastic}{{E_q}}}$ is the energy of the connection constraints  </span>, <span sym='E_a' context='elastic'>  ${\prosedeflabel{elastic}{{E_a}}}$ is the energy of the anchor constraints  </span>, <span sym='E_n' context='elastic'>  ${\prosedeflabel{elastic}{{E_n}}}$ is the energy of the notch-limit constraints  </span>, and <span sym='E_p' context='elastic'>  ${\prosedeflabel{elastic}{{E_p}}}$ is an additional notch penalty term that also serves to account for friction  </span>. We perform the simulation by minimizing <span sym='E' context='elastic'>  the entire energy ${\prosedeflabel{elastic}{{E}}}$ for the rod centerline points $x$   </span>using a Gauss-Newton method in a similar fashion as proposed by Vekhter et al. [2019]. In Section 6.2 we perform an empirical evaluation of the accuracy of the simulation by comparing it to laser-scans of the makes.</p>
<figure>
<img src="./img/img10.png" alt="Trulli" style="width:100%" class = "center">
<figcaption align = "center">Fig. 10. The influence of anchors and notches on the example Archway. Left: Anchors at the corners are not sufficient to push the grid into the right configuration. Center: Deployed state without notches, local buckling and irregularities in smoothness can be observed. Right: Notches relax the structure to a more natural, lower energy shape (cf. Sections 4.5 and 4.6).</figcaption> 
</figure>
<p>For the sake of readability, we will define the constraint energy terms only for a single constraint each. Er is the sum of stretching, bending and twisting energies of each individual rod. As a full explanation of the DER formulation is out of scope for this paper, we refer the reader to the work of [Bergou et al. 2010] for a detailed description of these terms.</p>
<p>The connection constraint energy ${\proselabel{elastic}{{E_q}}}$ is given by<br />

        <div class='equation' code_block="elastic">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_q$', 'elastic', 'def', false, '')", "id":"elastic-$E_q$", "sym":"$E_q$", "func":"elastic",  "localFunc":"", "type":"def", "case":"equation"} }{ {E_q} } & = \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$λ_{q,1}$', 'elastic', 'use', false, '')", "id":"elastic-$λ_{q,1}$", "sym":"$λ_{q,1}$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {λ_{q,1}} }\left\|\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$q_g$', 'elastic', 'use', false, '')", "id":"elastic-$q_g$", "sym":"$q_g$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {q_g} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$q_h$', 'elastic', 'use', false, '')", "id":"elastic-$q_h$", "sym":"$q_h$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {q_h} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't', 'elastic', 'use', false, '')", "id":"elastic-t", "sym":"t", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{t}} }\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$m_g$', 'elastic', 'use', false, '')", "id":"elastic-$m_g$", "sym":"$m_g$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {m_g} }\right\|_2^{2} + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$λ_{q,1}$', 'elastic', 'use', false, '')", "id":"elastic-$λ_{q,1}$", "sym":"$λ_{q,1}$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {λ_{q,1}} }\left\|\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$q_h$', 'elastic', 'use', false, '')", "id":"elastic-$q_h$", "sym":"$q_h$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {q_h} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$q_g$', 'elastic', 'use', false, '')", "id":"elastic-$q_g$", "sym":"$q_g$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {q_g} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't', 'elastic', 'use', false, '')", "id":"elastic-t", "sym":"t", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{t}} }\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$m_h$', 'elastic', 'use', false, '')", "id":"elastic-$m_h$", "sym":"$m_h$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {m_h} }\right\|_2^{2} + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$λ_{q,2}$', 'elastic', 'use', false, '')", "id":"elastic-$λ_{q,2}$", "sym":"$λ_{q,2}$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {λ_{q,2}} }\left\|\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$\\\\angle$', 'elastic', 'use', false, '')", "id":"elastic-$\\\\angle$", "sym":"$\\\\angle$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {\angle} }\left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$m_g$', 'elastic', 'use', false, '')", "id":"elastic-$m_g$", "sym":"$m_g$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {m_g} },\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$m_h$', 'elastic', 'use', false, '')", "id":"elastic-$m_h$", "sym":"$m_h$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {m_h} } \right)\right\|_2^{2}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'elastic', ['$m_g$', 't', '$λ_{q,2}$', '$q_g$', '$m_h$', '$q_h$', '$λ_{q,1}$', '$\\\\angle$', '$E_q$'], false, []);"} }{}
\end{align*}
\tag{2}\label{2}$$</div>
        <br />
with ${\proselabel{elastic}{{m_g}}}$ and ${\proselabel{elastic}{{m_h}}}$ denoting the material vectors of $g$ and $h$ at ${\proselabel{elastic}{{q}}}$ respectively. The term $tm$ accounts for the thickness of the rods, while ${\proselabel{elastic}{{λ_{q,1}}}}$ and ${\proselabel{elastic}{{λ_{q,2}}}}$ are the constraint weights for the position and direction terms.</p>
<p>The anchor constraint energy ${\proselabel{elastic}{{E_a}}}$ ensures that both the position ${\proselabel{elastic}{{q}}}$ and material vector ${\proselabel{elastic}{{m}}}$ of the given connection do not deviate from the position ${\proselabel{elastic}{{q_a}}}$ and material vector ${\proselabel{elastic}{{m_a}}}$ of the corresponding anchor. It is given by</p>
<p>
        <div class='equation' code_block="elastic">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_a$', 'elastic', 'def', false, '')", "id":"elastic-$E_a$", "sym":"$E_a$", "func":"elastic",  "localFunc":"", "type":"def", "case":"equation"} }{ {E_a} } & = \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$λ_{a,1}$', 'elastic', 'use', false, '')", "id":"elastic-$λ_{a,1}$", "sym":"$λ_{a,1}$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {λ_{a,1}} }\left\|\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'q', 'elastic', 'use', false, '')", "id":"elastic-q", "sym":"q", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{q}} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$q_a$', 'elastic', 'use', false, '')", "id":"elastic-$q_a$", "sym":"$q_a$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {q_a} }\right\|_2^{2} + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$λ_{a,2}$', 'elastic', 'use', false, '')", "id":"elastic-$λ_{a,2}$", "sym":"$λ_{a,2}$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {λ_{a,2}} }\left\|\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$\\\\angle$', 'elastic', 'use', false, '')", "id":"elastic-$\\\\angle$", "sym":"$\\\\angle$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {\angle} }\left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'm', 'elastic', 'use', false, '')", "id":"elastic-m", "sym":"m", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{m}} },\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$m_a$', 'elastic', 'use', false, '')", "id":"elastic-$m_a$", "sym":"$m_a$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {m_a} } \right)\right\|_2^{2}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'elastic', ['$λ_{a,2}$', '$m_a$', '$q_a$', 'q', '$λ_{a,1}$', 'm', '$\\\\angle$', '$E_a$'], false, []);"} }{}
\end{align*}
\tag{3}\label{3}$$</div>
        </p>
<p>with ${\proselabel{elastic}{{λ_{a,1}}}}$ and ${\proselabel{elastic}{{λ_{a,2}}}}$ as weights. This constraint applies to the grid corners and anchors.</p>
<p><span sym='E_n' context='elastic'>  The notch-limit constraint energy ${\prosedeflabel{elastic}{{E_n}}}$   </span>ensures that the connection point remains within the bounds of the notch. They are specified by the notch length l and the sliding direction (cf. Section 4.5):</p>
<p>
        <div class='equation' code_block="elastic">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_n$', 'elastic', 'def', false, '')", "id":"elastic-$E_n$", "sym":"$E_n$", "func":"elastic",  "localFunc":"", "type":"def", "case":"equation"} }{ {E_n} } & = \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$δ^{(−)}$', 'elastic', 'use', false, '')", "id":"elastic-$δ^{(−)}$", "sym":"$δ^{(−)}$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {δ^{(−)}} }{\left( \frac{1}{10} \log{ \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β_q$', 'elastic', 'use', false, '')", "id":"elastic-$β_q$", "sym":"$β_q$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {β_q} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β^{(−)}$', 'elastic', 'use', false, '')", "id":"elastic-$β^{(−)}$", "sym":"$β^{(−)}$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {β^{(−)}} } \right) } \right)}^{2} + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$δ^{(+)}$', 'elastic', 'use', false, '')", "id":"elastic-$δ^{(+)}$", "sym":"$δ^{(+)}$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {δ^{(+)}} }{\left( \frac{1}{10} \log{ \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β^{(+)}$', 'elastic', 'use', false, '')", "id":"elastic-$β^{(+)}$", "sym":"$β^{(+)}$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {β^{(+)}} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β_q$', 'elastic', 'use', false, '')", "id":"elastic-$β_q$", "sym":"$β_q$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {β_q} } \right) } \right)}^{2}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'elastic', ['$δ^{(+)}$', '$β_q$', '$δ^{(−)}$', '$β^{(−)}$', '$β^{(+)}$', '$E_n$'], false, []);"} }{}
\end{align*}
\tag{4}\label{4}$$</div>
        </p>
<p>with ${\proselabel{elastic}{{β^{(−)}}}}$ and ${\proselabel{elastic}{{β^{(+)}}}}$ denoting the barycentric coordinates of the notch bounds on their corresponding edges. The term is only active when the connection lies on the same rod-edge as one of the notch bounds, so ${\proselabel{elastic}{{δ^{(−)}}}} = 1$ or ${\proselabel{elastic}{{δ^{(+)}}}} = 1$ when the connection lies on one of these edges, and 0 otherwise.</p>
<p>The additional notch penalty term ${\proselabel{elastic}{{E_p}}}$ controls the movement of a connection q between two adjacent edges. If ${\proselabel{elastic}{{q}}}$ switches edges, it needs to be reprojected to the neighboring edge at the next iteration of the simulation. Within an iteration, ${\proselabel{elastic}{{E_p}}}$ prevents ${\proselabel{elastic}{{q}}}$ from moving too far beyond the end of the current edge:</p>
<p>
        <div class='equation' code_block="elastic">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$E_p$', 'elastic', 'def', false, '')", "id":"elastic-$E_p$", "sym":"$E_p$", "func":"elastic",  "localFunc":"", "type":"def", "case":"equation"} }{ {E_p} } & = {\left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'μ', 'elastic', 'use', false, '')", "id":"elastic-μ", "sym":"μ", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{μ}} } \log{ \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'ε', 'elastic', 'use', false, '')", "id":"elastic-ε", "sym":"ε", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{ε}} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β_q$', 'elastic', 'use', false, '')", "id":"elastic-$β_q$", "sym":"$β_q$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {β_q} } \right) } \right)}^{2} + {\left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'μ', 'elastic', 'use', false, '')", "id":"elastic-μ", "sym":"μ", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{μ}} } \log{ \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'ε', 'elastic', 'use', false, '')", "id":"elastic-ε", "sym":"ε", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{ε}} } + 1 - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$β_q$', 'elastic', 'use', false, '')", "id":"elastic-$β_q$", "sym":"$β_q$", "func":"elastic",  "localFunc":"", "type":"use", "case":"equation"} }{ {β_q} } \right) } \right)}^{2}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'elastic', ['ε', '$β_q$', 'μ', '$E_p$'], false, []);"} }{}
\end{align*}
\tag{5}\label{5}$$</div>
        <br />
with <span sym='ε' context='elastic'>  ${\prosedeflabel{elastic}{{ε}}}$ denoting how far ${\proselabel{elastic}{{q}}}$ is allowed to move past the end of the edge  </span> and <span sym='μ' context='elastic'>  ${\prosedeflabel{elastic}{{μ}}}$ acting as a weighting parameter  </span>(we choose ${\proselabel{elastic}{{ε}}} = 0.0001$, ${\proselabel{elastic}{{μ}}} = 0.1$).</p>
<figure>
<img src="./img/img11.png" alt="Trulli" style="width:100%" class = "center">
<figcaption align = "center">Fig. 11. The effect of the weighting parameter ${\proselabel{elastic}{{μ}}}$ in ${\proselabel{elastic}{{E_p}}}$ (from left to right): surface shaded with K and geodesics; ${\proselabel{elastic}{{μ}}} = 0.01$, rods slide onto geodesics; ${\proselabel{elastic}{{μ}}} = 0.1$, sliding in high $K$ areas reduced (our setting); ${\proselabel{elastic}{{μ}}} = 1$, sliding is heavily reduced. Refer to Section 7.3 for a further discussion on ${\proselabel{elastic}{{μ}}}$.</figcaption> 
</figure>

<p>Since ${\proselabel{elastic}{{E_p}}}$ is not 0 even inside the edge, it penalizes very small sliding movements that would otherwise accumulate over many iterations. In other words, ${\proselabel{elastic}{{E_p}}}$ creates a pseudo-frictional effect, which is controlled by ${\proselabel{elastic}{{μ}}}$. In a physical grid, friction creates a force acting against the sliding movement of a connection. If the driving force of the movement and the frictional force counterbalance, the movement stops. This situation has an analogy in our grids. A connection stops moving inside a notch if</p>
<p>$$\frac{\partial E_q}{\partial β_q} + \frac{\partial E_p}{\partial β_q} = 0 \tag{6}\label{6}$$</p>
<p>is fulfilled. Figure 11 depicts the effects of different values for ${\proselabel{elastic}{{μ}}}$.</p>
<div class="references"></div>
</body>
</html>