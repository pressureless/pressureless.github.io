<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
    <script>
MathJax = {
  loader: {
    load: ["[attrLabel]/attr-label.js"],
    paths: { attrLabel: "../resource" },
  },
  tex: { packages: { "[+]": ["attr-label"] },
   inlineMath: [['$', '$']]
   },
   options: {
    enableAssistiveMml: false
  },
};
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <script src="../resource/d3.min.js"></script>
    <script src="../resource/svg.min.js"></script>
    <script type="text/javascript" src='../resource/paper.js'></script>
    <link rel="stylesheet" href="../resource/paper.css">
</head>
<script>
const iheartla_data = JSON.parse('{"equations":[{"name":"icp", "parameters":[{"sym":"R", "type_info":{"type": "matrix", "element":{"type": "scalar"}, "rows":"3", "cols":"3"}},{"sym":"a", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "desc":"axis of rotation"},{"sym":"θ", "type_info":{"type": "scalar"}, "desc":"angle of rotation"},{"sym":"p", "type_info":{"type": "sequence", "element":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "size":"dim_0"}},{"sym":"q", "type_info":{"type": "sequence", "element":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "size":"dim_0"}},{"sym":"$n_q$", "type_info":{"type": "sequence", "element":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "size":"dim_0"}},{"sym":"$n_p$", "type_info":{"type": "sequence", "element":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "size":"dim_0"}},{"sym":"t", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}}], "definition":[{"sym":"ã", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}},{"sym":"n", "type_info":{"type": "sequence", "element":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "size":"dim_0"}},{"sym":"t̃", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}},{"sym":"$\\\\varepsilon_{point}$", "type_info":{"type": "scalar"}},{"sym":"$\\\\varepsilon_{plane}$", "type_info":{"type": "scalar"}},{"sym":"$\\\\varepsilon_{symm-RN}$", "type_info":{"type": "scalar"}},{"sym":"$\\\\varepsilon_{symm}$", "type_info":{"type": "scalar"}},{"sym":"$\\\\varepsilon_{two-plane}$", "type_info":{"type": "scalar"}}], "local_func":[], "source":"ã = a tan(θ)\\nn_i = `$n_q$`_i + `$n_p$`_i\\nt̃ = t/cos(θ)\\n`$\\\\varepsilon_{point}$` = ∑_i ||R p_i + t - q_i||\\nR ∈ ℝ^(3 × 3)\\n\\n`$\\\\varepsilon_{plane}$` = ∑_i ((R p_i + t - q_i) ⋅ `$n_q$`_i)^2\\n\\n`$\\\\varepsilon_{symm-RN}$` = ∑_i ((R p_i + R⁻¹ q_i + t) ⋅ (R`$n_p$`_i + R⁻¹`$n_q$`_i))^2\\n\\ntan, cos from trigonometry\\n\\n`$\\\\varepsilon_{symm}$` = ∑_i cos²(θ)((p_i - q_i)⋅n_i +((p_i+q_i)×n_i)⋅ã+n_i⋅t̃)² \\n\\nwhere\\na ∈ ℝ³ : axis of rotation\\nθ ∈ ℝ  : angle of rotation\\np_i ∈ ℝ³\\nq_i ∈ ℝ³\\n`$n_q$`_i ∈ ℝ³\\n`$n_p$`_i ∈ ℝ³\\nt ∈ ℝ³\\n\\n`$\\\\varepsilon_{two-plane}$` = ∑_i(((R p_i + R⁻¹ q_i + t) ⋅ (R `$n_p$`_i))^2 + ((R p_i + R⁻¹ q_i + t) ⋅ (R⁻¹`$n_q$`_i))^2)\\n" }] }');
const sym_data = JSON.parse('{"R":[{"desc":"None", "type_info":{"type": "matrix", "element":{"type": "scalar"}, "rows":"3", "cols":"3"}, "def_module":"icp", "is_defined":false, "used_equations":[]}],"a":[{"desc":"axis of rotation", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "def_module":"icp", "is_defined":false, "used_equations":[]}],"θ":[{"desc":"angle of rotation", "type_info":{"type": "scalar"}, "def_module":"icp", "is_defined":false, "used_equations":[]}],"p":[{"desc":"None", "type_info":{"type": "sequence", "element":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "size":"dim_0"}, "def_module":"icp", "is_defined":false, "used_equations":[]}],"q":[{"desc":"None", "type_info":{"type": "sequence", "element":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "size":"dim_0"}, "def_module":"icp", "is_defined":false, "used_equations":[]}],"$n_q$":[{"desc":"None", "type_info":{"type": "sequence", "element":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "size":"dim_0"}, "def_module":"icp", "is_defined":false, "used_equations":[]}],"$n_p$":[{"desc":"None", "type_info":{"type": "sequence", "element":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "size":"dim_0"}, "def_module":"icp", "is_defined":false, "used_equations":[]}],"t":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "def_module":"icp", "is_defined":false, "used_equations":[]}],"ã":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "def_module":"icp", "is_defined":true, "used_equations":[]}],"n":[{"desc":"None", "type_info":{"type": "sequence", "element":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "size":"dim_0"}, "def_module":"icp", "is_defined":true, "used_equations":[]}],"t̃":[{"desc":"None", "type_info":{"type": "vector", "element":{"type": "scalar"}, "rows":"3"}, "def_module":"icp", "is_defined":true, "used_equations":[]}],"$\\\\varepsilon_{point}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"icp", "is_defined":true, "used_equations":[]}],"$\\\\varepsilon_{plane}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"icp", "is_defined":true, "used_equations":[]}],"$\\\\varepsilon_{symm-RN}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"icp", "is_defined":true, "used_equations":[]}],"$\\\\varepsilon_{symm}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"icp", "is_defined":true, "used_equations":[]}],"$\\\\varepsilon_{two-plane}$":[{"desc":"None", "type_info":{"type": "scalar"}, "def_module":"icp", "is_defined":true, "used_equations":[]}]}');
window.onload = parseAllSyms;
function reportWindowSize() {
  var arrows = document.querySelectorAll(".arrow");
  if (arrows) {
    for (var i = arrows.length - 1; i >= 0; i--) {
      var arrow = arrows[i];
      var body = document.querySelector("body");
      var style = window.getComputedStyle(body);
      var curOffset = parseInt(style.marginLeft, 10)
      var oldOffset = arrow.getAttribute('offset');
      arrow.setAttribute('offset', curOffset);
      // console.log(`oldOffset:${oldOffset}, curOffset:${curOffset}`);
      var arrowStyle = window.getComputedStyle(arrow); 
      var arrowOffset = parseInt(document.querySelector(".arrow").style.marginLeft, 10)
      arrow.style.marginLeft = `${arrowOffset+curOffset-oldOffset}px`;
      var newWidth = parseInt(style.width, 10) + parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
      arrow.style.width = `${newWidth}px`;
      arrow.style.height = style.height; 
      // console.log(`arrow.style.width:${arrow.style.width}, arrow.style.height:${arrow.style.height}`)
    }
  }
}
window.onresize = reportWindowSize;
document.addEventListener("click", function(evt){
    resetState();
});

</script>
<body>
<img src="../resource/glossary.png" id="glossary" alt="glossary" width="22" height="28"><br>
<div class='title'>A Symmetric Objective Function for ICP</div><div class='author'>SZYMON RUSINKIEWICZ, Princeton University</div><p class='abstract'>The Iterative Closest Point (ICP) algorithm, commonly used for alignment of 3D models, has previously been defined using either a point-to-point or point-to-plane objective. Alternatively, researchers have proposed computationally-expensive methods that directly minimize the distance function between surfaces. We introduce a new symmetrized objective function that achieves the simplicity and computational efficiency of point-to-plane optimization, while yielding improved convergence speed and a wider convergence basin. In addition, we present a linearization of the objective that is exact in the case of exact correspondences. We experimentally demonstrate the improved speed and convergence basin of the symmetric objective, on both smooth models and challenging cases involving noise and partial overlap.</p><ul><li><a href='#introduction'>1&nbsp;INTRODUCTION</a></li><li><a href='#related-work'>2&nbsp;RELATED WORK</a></li><li><a href='#method'>3&nbsp;METHOD</a><ul><li><a href='#background-and-motivation'>3.1&nbsp;Background and Motivation</a></li><li><a href='#a-symmetric-objective-function'>3.2&nbsp;A Symmetric Objective Function</a></li><li><a href='#linear-approximation'>3.3&nbsp;Linear Approximation</a></li></ul></li><li><a href='#theoretical-and-experimental-results'>4&nbsp;THEORETICAL AND EXPERIMENTAL RESULTS</a><ul><li><a href='#the-symmetric-error-is-zero-when-corresponding-points-are-consistent-with-a-quadratic-surface'>4.1&nbsp;The Symmetric Error Is Zero When Corresponding Points Are Consistent With a Quadratic Surface</a></li><li><a href='#the-linearization-is-exact-for-exact-correspondences'>4.2&nbsp;The Linearization is Exact for Exact Correspondences</a></li><li><a href='#proselabelicp-varepsilon_symm-accelerates-per-iteration-convergence'>4.3&nbsp;$\proselabel{icp}{  \varepsilon_{symm}  }$ Accelerates Per-Iteration Convergence</a></li><li><a href='#icp-with-proselabelicpvarepsilon_symm-has-a-wide-convergence-basin'>4.4&nbsp;ICP with $\proselabel{icp}{\varepsilon_{symm}}$ Has a Wide Convergence Basin</a></li></ul></li><li><a href='#discussion-and-future-work'>5&nbsp;DISCUSSION AND FUTURE WORK</a></li><li><a href='#references'>6&nbsp;REFERENCES</a></li></ul>
<h1 id='introduction'>1&nbsp;INTRODUCTION</h1><p>Registration of 3D shapes is a key step in both 3D model creation (from scanners or computer vision systems) and shape analysis. For rigid-body alignment based purely on geometry (as opposed to RGB-D), the most common methods are based on variants of the Iterative Closest Point (ICP) algorithm <a href="#ref1">[Besl and McKay 1992]</a>. In this method, points are repeatedly selected from one model, their nearest points on the other model (given the current best-estimate rigidbody alignment) are selected as correspondences, and an incremental transformation is found that minimizes distances between point pairs. The algorithm eventually converges to a local minimum of surface-to-surface distance. </p>
<p>Because ICP-like algorithms can be made efficient and reliable, they have become widely adopted. As a result, researchers have focused on both addressing the shortcomings of ICP and extending it to new settings such as color-based registration and non-rigid alignment. One particular class of improvements has focused on the loss function that is optimized to obtain an incremental transformation. For example, as compared to the original work of Besl and McKay, which minimized point-to-point distance, the method of <a href="#ref4">Chen and Medioni [1992]</a> minimized the distance between a point on one mesh and a plane containing the matching point and perpendicular to its normal. This point-to-plane objective generally results in faster convergence to the correct alignment and greater ultimate accuracy, though it does not necessarily increase the basin of convergence. Work by <a href="#ref10">Fitzgibbon [2001]</a>, <a href="#ref19">Mitra et al. [2004]</a>, and <a href="#ref22">Pottmann et al. [2006]</a> showed that both point-to-point and point-to-plane minimization may be thought of as approximations to minimizing the squared Euclidean distance function of the surface, and they presented algorithms that achieved greater convergence speed and stability, albeit at the cost of greater computational complexity and/or auxiliary data structures.</p>
<p>This paper proposes a symmetrized version of the point-to-plane objective for use in ICP, incorporating two key ideas. First, the plane in which the error is minimized is based on the surface normals of both points in the corresponding pair. Second, the optimization is performed in a &ldquo;stationary&rdquo; coordinate system, while both meshes are moved in opposite directions. These changes require a relatively small modification to the optimization problem being performed, and almost no increased computation per iteration, but result in improved convergence of ICP.</p>
<p>The reason for this improvement is that the symmetric objective is minimized whenever the pair of points lies on a second-order (constant-curvature) patch of surface, rather than being minimized only if the points are on a plane. Thus, we gain some of the same benefits as second-order distance function minimization methods, but without explicit computation of second-order surface properties, or the need for volumetric data structures to store an approximation to the squared Euclidean distance function.</p>
<p>In addition to the primary contribution of the new symmetric objective, we also introduce an alternative approach to linearization of rotations that allows us to reduce the optimization to a linear least-squares problem, while still solving for the exact transformation when correspondences are exact. We conduct experiments that demonstrate both greater per-iteration error reduction and an increase in the convergence basin for our proposed method.</p>
<h1 id='related-work'>2&nbsp;RELATED WORK</h1><p>Since the original ICP algorithms by <a href="#ref1">Besl and McKay [1992]</a> and <a href="#ref4">Chen and Medioni [1992]</a>, there have been significant efforts to improve convergence and stability. For a comprehensive overview of many variants, see the surveys by <a href="#ref24">Rusinkiewicz and Levoy [2001]</a>, <a href="#ref7">Díez et al. [2015]</a>, and <a href="#ref21">Pomerleau et al. [2015]</a>. Much of this work focuses on finding better correspondences (e.g., by matching local surface properties or descriptors), performing outlier-tolerant optimization, or generalizing to non-rigid deformation. Here we focus specifically on methods that modify the objective function and/or the strategy for minimizing it.</p>
<p><a href="#ref25">Segal et al. [2009]</a> generalize ICP to associate a probabilistic model (in practice, a covariance matrix) with each point. This allows for a &ldquo;soft plane-to-plane&rdquo; minimization that improves the matching of planar surfaces. <a href="#ref13">Halber and Funkhouser [2017]</a> have explored incorporating additional constraints between planes, such as parallelism or orthogonality, into registration.</p>
<p><a href="#ref10">Fitzgibbon [2001]</a> proposes to directly minimize the distance between samples on one shape (referred to as &ldquo;data&rdquo;) and the second shape itself (the &ldquo;model&rdquo;). This is done by computing the squared distance transform of the model, evaluating it at data locations, applying a robustifying kernel, and minimizing the result using Levenberg-Marquardt. <a href="#ref19">Mitra et al. [2004]</a> propose two methods for using the distance field of a shape for optimization: one based on local quadratic approximation at closest corresponding points, and the other based on a global hierarchical $d^2$-Tree data structure <a href="#ref16">[Leopoldseder et al. 2003]</a> that stores a bounded-error approximation to the global squared distance field. <a href="#ref22">Pottmann et al. [2006]</a> analyze the theoretical properties of distance-function minimization, and demonstrate its improved convergence.</p>
<p>The variants described above all perform local minimization, requiring an initial guess. This may be based on exhaustive search, matching of descriptors (such as spin images <a href="#ref14">[Huber and Hebert 2003]</a> or integral invariants <a href="#ref12">[Gelfand et al. 2005]</a>), or finding constrained point arrangements <a href="#ref0">[Aiger et al. 2008]</a>. In contrast, <a href="#ref30">Yang et al. [2016]</a> combine local registration with a branch-and-bound algorithm that yields a provably globally-optimal solution. The loss function, however, is still based on point-to-point, which is exploited for derivation of the error bounds for global search.</p>
<p>In this paper, we derive an objective that is closest in spirit to simple point-to-plane minimization, but locally converges to zero for quadratic, rather than just planar, patches. This is done by considering the normals of both points in a pair, though we do so in a way unrelated to <a href="#ref25">Segal et al. [2009]</a>.</p>
<h1 id='method'>3&nbsp;METHOD</h1><h2 id='background-and-motivation'>3.1&nbsp;Background and Motivation</h2><p>Consider the problem of aligning surfaces $P$ and $Q$. This involves finding<span sym='R' context='second'>  a rigid-body transformation $(\prosedeflabel{icp}{R}|{\proselabel{icp}{{t}}})$ such that applying the transformation to $P$ causes it to lie on top of $Q$ </span>. The original ICP algorithm of <a href="#ref1">Besl and McKay [1992]</a> may be thought of as an instance of Expectation Maximization: the problem is solved by alternately computing pairs of corresponding points $({\proselabel{icp}{{p}}}_i, {\proselabel{icp}{{q}}}_i)$, where ${\proselabel{icp}{{q}}}_i$ is the closest point to ${\proselabel{icp}{{p}}}_i$ given the current transformation, and finding the transformation minimizing the point-to-point objective:</p>
<p>
        <div class='equation' code_block="icp">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$\\\\varepsilon_{point}$', 'icp', 'def', false, '')", "id":"icp-$\\\\varepsilon_{point}$", "sym":"$\\\\varepsilon_{point}$", "func":"icp",  "localFunc":"", "type":"def", "case":"equation"} }{ {\varepsilon_{point}} } & = \sum_{\mathit{i}} \left\|\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'p', 'icp', 'use', false, '')", "id":"icp-p", "sym":"p", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{p}} }_{ \mathit{i} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't', 'icp', 'use', false, '')", "id":"icp-t", "sym":"t", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{t}} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'q', 'icp', 'use', false, '')", "id":"icp-q", "sym":"q", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{q}} }_{ \mathit{i} }\right\|_2\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'icp', ['q', 't', 'p', 'R', '$\\\\varepsilon_{point}$'], false, []);"} }{}
\end{align*}
\tag{1}\label{1}$$</div>
        </p>
<p>Because this iteration converges slowly, authors including <a href="#ref10">Fitzgibbon [2001]</a>, <a href="#ref19">Mitra et al. [2004]</a>, and <a href="#ref22">Pottmann et al. [2006]</a> have re-cast alignment as iterative minimization of the squared Euclidean distance function of $Q$, sampled at points ${\proselabel{icp}{{p}}}_i$. The most accurate way to accomplish this is to pre-compute a data structure that stores at each point in space (an approximation to) the squared distance field, then use it at run-time in an optimization based on Levenberg-Marquardt <a href="#ref10">[Fitzgibbon 2001]</a> or Newton’s method <a href="#ref19">[Mitra et al. 2004]</a>. This leads to fast convergence and a wide convergence basin, though at significant computational and storage cost. A simpler approach is to approximate the distance function based on the local surface at each corresponding point ${\proselabel{icp}{{q}}}_i$. The &ldquo;on-demand&rdquo; method of <a href="#ref19">Mitra et al. [2004]</a> approximates the surface as locally quadratic, which requires evaluation of second-order surface properties (i.e., curvatures). Even more straightforward is to approximate the surface around ${\proselabel{icp}{{q}}}_i$ as planar, which only requires evaluation of surface normals $\prosedeflabel{icp}{{n_q}}_{,i}$ . Indeed, this approach dates back to the work of <a href="#ref4">Chen and Medioni [1992]</a>, who minimized what has come to be called the point-to-plane objective:<br />

        <div class='equation' code_block="icp">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$\\\\varepsilon_{plane}$', 'icp', 'def', false, '')", "id":"icp-$\\\\varepsilon_{plane}$", "sym":"$\\\\varepsilon_{plane}$", "func":"icp",  "localFunc":"", "type":"def", "case":"equation"} }{ {\varepsilon_{plane}} } & = \sum_{\mathit{i}} {\left( \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'p', 'icp', 'use', false, '')", "id":"icp-p", "sym":"p", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{p}} }_{ \mathit{i} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't', 'icp', 'use', false, '')", "id":"icp-t", "sym":"t", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{t}} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'q', 'icp', 'use', false, '')", "id":"icp-q", "sym":"q", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{q}} }_{ \mathit{i} } \right) \cdot \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$n_q$', 'icp', 'use', false, '')", "id":"icp-$n_q$", "sym":"$n_q$", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {n_q} }_{ \mathit{i} } \right)}^{2}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'icp', ['q', 't', 'R', '$n_q$', 'p', '$\\\\varepsilon_{plane}$'], false, []);"} }{}
\end{align*}
\tag{2}\label{2}$$</div>
        </p>
<p>It can be shown that minimizing this objective is equivalent to Gauss-Newton minimization of squared Euclidean distance.</p>
<p>The latter does indeed improve convergence rate relative to the point-to-point objective, and point-to-plane minimization has become the workhorse of most modern ICP-like implementations. However, point-to-plane ICP has been observed to have a narrower convergence basin than point-to-point <a href="#ref19">[Mitra et al. 2004]</a>. In addition, the residual at optimal alignment is zero only when the surface is locally flat, if the correspondences are not perfect (which is necessarily the case if point sets {${\proselabel{icp}{{p}}}_i$} and {${\proselabel{icp}{{q}}}_i$} differ in their sampling of the surface, as with 3D scans). This is important because the zero-set of the objective function defines what transformations are &ldquo;free,&rdquo; in the sense that the surface is allowed to slide along itself to permit geometric features elsewhere to lock down the transformation. This is exploited by work such as the normalspace sampling of <a href="#ref24">Rusinkiewicz and Levoy [2001]</a>, the covariance-eigenvector-directed sampling of <a href="#ref11">Gelfand et al. [2003]</a>, and the stable sampling of <a href="#ref3">Brown and Rusinkiewicz [2007]</a>, all of which bias the sampling to regions that are most necessary to constrain the aligning transformation.</p>
<p>We therefore seek to develop a new objective function whose zero-set allows a greater class of surfaces to &ldquo;slide along&rdquo; themselves at zero penalty. Thinking within the framework of Expectation Maximization, this makes the method as robust as possible to mis-estimation of point correspondences in the Expectation step.</p>
<h2 id='a-symmetric-objective-function'>3.2&nbsp;A Symmetric Objective Function</h2><p>Because the surfaces $P$ and $Q$ should be, up to noise, the same, we consider what residual the objective function will attain if we were to sample a pair of nearby points $({\proselabel{icp}{{p}}}, {\proselabel{icp}{{q}}})$ on that surface. In the point-to-plane case, the error is<br />
$$({\proselabel{icp}{{p}}}-{\proselabel{icp}{{q}}})\cdot {\proselabel{icp}{{n_q}}}\tag{3}\label{3}$$<br />
If we consider the possibility of sampling $({\proselabel{icp}{{p}}}, {\proselabel{icp}{{q}}})$ anywhere within some small region of a surface, this will be zero only if the surface is perfectly flat. However, consider the more symmetric function</p>
<p>$$({\proselabel{icp}{{p}}}-{\proselabel{icp}{{q}}})\cdot ({\proselabel{icp}{{n_p}}} + {\proselabel{icp}{{n_q}}})\tag{4}\label{4}$$</p>
<figure>
<img src="./img/icp-1.png" alt="Trulli" style="width:50%" class = "center">
<figcaption align = "center">Fig. 1. For any points ${\proselabel{icp}{{p}}}$ and ${\proselabel{icp}{{q}}}$ sampled from a circular arc, the vector between them ${\proselabel{icp}{{p}}} − {\proselabel{icp}{{q}}}$ is perpendicular to the sum of normals ${\proselabel{icp}{{n_p}}} + {\proselabel{icp}{{n_q}}}$ . This is the fundamental property exploited by the symmetric ICP formulation.</figcaption>
</figure>
<p>Examining the behavior of this function in 2D (see Figure 1), we see that it is zero whenever ${\proselabel{icp}{{p}}}$ and ${\proselabel{icp}{{q}}}$ are sampled from a circle, since ${\proselabel{icp}{{n_p}}}$ and ${\proselabel{icp}{{n_q}}}$ have opposite projections onto ${\proselabel{icp}{{p}}} − {\proselabel{icp}{{q}}}$. As rigid-body transformations are applied to $P$, this expression will continue to evaluate to zero as long as ${\proselabel{icp}{{p}}}$ and ${\proselabel{icp}{{q}}}$ end up in a relative position consistent with their placement on some circle (Figure 2, top). A similar property is true in 3D: Equation $\ref{4}$ evaluates to zero as long as ${\proselabel{icp}{{p}}}$ and ${\proselabel{icp}{{q}}}$ and their normals are consistent with some cylinder. Because it is difficult to describe, and especially to visualize, the set of $({\proselabel{icp}{{p}}}, {\proselabel{icp}{{n_p}}})$ that lie on arbitrary cylinders containing a fixed $({\proselabel{icp}{{n_q}}}, {\proselabel{icp}{{n_q}}})$ - it is a 4D space - Section 4.1 investigates a different property: Equation $\ref{4}$ also holds whenever ${\proselabel{icp}{{p}}}$ and ${\proselabel{icp}{{q}}}$ are consistent with a locally-second-order surface centered between them. While this constraint still provides a great deal of freedom for $({\proselabel{icp}{{p}}}, {\proselabel{icp}{{n_p}}})$ to move relative to $({\proselabel{icp}{{q}}}, {\proselabel{icp}{{n_q}}})$, it is a &ldquo;more useful&rdquo; form of freedom than provided by the point-to-plane metric. In particular, it constrains $({\proselabel{icp}{{p}}}, {\proselabel{icp}{{n_p}}})$ to be consistent with a plausible extension of $({\proselabel{icp}{{n_q}}}, {\proselabel{icp}{{n_q}}})$, unlike point-to-plane (Figure 2, bottom). Note that achieving this property does not require the evaluation of any higher-order information (i.e., curvature), which is a major benefit for computational efficiency and noise resistance.</p>
<p>To formulate an objective function, we consider minimizing Equation $\ref{4}$ with respect to transformations applied to the surfaces $P$ and/or $Q$. Although most previous work applies a rigid-body transformation to only one of the surfaces (e.g., the transformation in $\varepsilon_{plane}$ is applied only to $P$), we consider a symmetric split of the transformation: we imagine evaluating the metric in a fixed, &ldquo;neutral&rdquo; coordinate system and applying opposite transformations to $P$ and $Q$. Thus, we can formulate a symmetric objective as:<br />

        <div class='equation' code_block="icp">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$\\\\varepsilon_{symm-RN}$', 'icp', 'def', false, '')", "id":"icp-$\\\\varepsilon_{symm-RN}$", "sym":"$\\\\varepsilon_{symm-RN}$", "func":"icp",  "localFunc":"", "type":"def", "case":"equation"} }{ {\varepsilon_{symm-RN}} } & = \sum_{\mathit{i}} {\left( \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'p', 'icp', 'use', false, '')", "id":"icp-p", "sym":"p", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{p}} }_{ \mathit{i} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }^{-1}\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'q', 'icp', 'use', false, '')", "id":"icp-q", "sym":"q", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{q}} }_{ \mathit{i} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't', 'icp', 'use', false, '')", "id":"icp-t", "sym":"t", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{t}} } \right) \cdot \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$n_p$', 'icp', 'use', false, '')", "id":"icp-$n_p$", "sym":"$n_p$", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {n_p} }_{ \mathit{i} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }^{-1}\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$n_q$', 'icp', 'use', false, '')", "id":"icp-$n_q$", "sym":"$n_q$", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {n_q} }_{ \mathit{i} } \right) \right)}^{2}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'icp', ['q', 't', 'R', '$n_q$', '$n_p$', 'p', '$\\\\varepsilon_{symm-RN}$'], false, []);"} }{}
\end{align*}
\tag{5}\label{5}$$</div>
        <br />
where the final transformation from $P$ to $Q$ is now ${\proselabel{icp}{{R}}}  T  {\proselabel{icp}{{R}}}$ (with $T$ being the translation matrix). We will refer to this as the rotated-normals (&ldquo;-RN&rdquo;) version of the symmetric objective.</p>
<p>This splitting of rotations has a number of advantages when we consider linearizing the objective (Section 3.3):</p>
<ul>
<li>It reduces linearization error by optimizing for half of the rotation angle.</li>
<li>It further reduces error, because the error in linearizing $Rp − {\proselabel{icp}{{q}}}$ is proportional to ${\proselabel{icp}{{p}}} · {\proselabel{icp}{{a}}}$, where a is the rotation axis, while the error in linearizing $Rp − {\proselabel{icp}{{R}}}^{-1}{\proselabel{icp}{{q}}}$ is proportional to $({\proselabel{icp}{{p}}} − {\proselabel{icp}{{q}}}) · {\proselabel{icp}{{a}}}$. Except for extreme misalignment, ${\proselabel{icp}{{p}}} − {\proselabel{icp}{{q}}}$ is usually smaller than ${\proselabel{icp}{{p}}}$ (i.e., the distance from ${\proselabel{icp}{{p}}}$ to the origin).</li>
<li>It enables reduction of linearization error to zero when correspondences are exact (Section 4.2).</li>
</ul>
<p>We have also explored a simpler version of this objective in which the normals are not rotated. That is, the direction of minimization per point pair remains fixed, while the points themselves are rotated in opposite directions:<br />
$$\proselabel{icp}{\varepsilon_{symm}}  = \sum_i {\left[ \left( {\proselabel{icp}{{R}}} {\proselabel{icp}{{p}}}_i + {\proselabel{icp}{{R}}}^{-1} {\proselabel{icp}{{q}}}_i + \proselabel{icp}{t} \right) \cdot \left(\proselabel{icp}{{n_p}}_i + \proselabel{icp}{{n_q}}_i \right) \right]}^{2} 
\tag{6}\label{6}$$</p>
<figure>
<img src="./img/icp-2.png" alt="Trulli" style="width:90%" class = "center">
<figcaption align = "center">Fig.2. Top:As ${\proselabel{icp}{{p}}}$ moves relative to ${\proselabel{icp}{{q}}}$,the property$({\proselabel{icp}{{p}}}−{\proselabel{icp}{{q}}})·({\proselabel{icp}{{n_p}}} +{\proselabel{icp}{{n_q}}})=0$ holds as long as there is some circular arc with which ${\proselabel{icp}{{p}}}$, ${\proselabel{icp}{{q}}}$, ${\proselabel{icp}{{n_p}}}$, and ${\proselabel{icp}{{n_q}}}$ are consistent. Bottom: This is in contrast to the point-to-plane metric, which is zero when ${\proselabel{icp}{{p}}}$ is in the plane defined by ${\proselabel{icp}{{q}}}$ and ${\proselabel{icp}{{n_q}}}$, regardless of ${\proselabel{icp}{{p}}}$.</figcaption>
</figure>
<p>Why might this be a reasonable simplification to make? Consider the sum of two unit-length vectors in 2D. Applying opposite rotations to the vectors preserves the direction of their sum, so that the contribution of each point pair to the two variants of the objective would be the same up to a scale. In 3D, this is not true for all rotation axes, but approaches true as np approaches nq . The experiments in Section 4.3 show that the two objectives lead to similar convergence, but $\proselabel{icp}{\varepsilon_{symm}}$ leads to simpler derivations and implementation. Therefore, the remainder of this paper adopts $\proselabel{icp}{\varepsilon_{symm}}$ as the symmetric objective.</p>
<h2 id='linear-approximation'>3.3&nbsp;Linear Approximation</h2><p>The traditional method for converting an objective function involving rotations into an easily-optimized linear least-squares system is to make the approximations $\cos \proselabel{icp}{θ} ∼ 1$, $\sin \proselabel{icp}{θ} ∼ \proselabel{icp}{θ}$, for small incremental rotations $\proselabel{icp}{θ}$. This converts the rotation matrix ${\proselabel{icp}{{R}}}$ into a linear form, which then yields a linear least-squares system.</p>
<p>We instead pursue a linearization that starts with the Rodrigues rotation formula for the effect of a rotation ${\proselabel{icp}{{R}}}$ on a vector $\proselabel{icp}{v}$:</p>
<p>$$R\proselabel{icp}{v} = \proselabel{icp}{v}\cos \proselabel{icp}{θ} + (\proselabel{icp}{a}\times \proselabel{icp}{v})\sin \proselabel{icp}{θ} + \proselabel{icp}{a}(\proselabel{icp}{a}\cdot \proselabel{icp}{v})(1-\cos\proselabel{icp}{θ})\tag{7}\label{7}$$</p>
<p>where $\proselabel{icp}{a}$ and $\proselabel{icp}{θ}$ are the axis and angle of rotation. We observe that the last term in (7) is quadratic in the incremental rotation angle $\proselabel{icp}{θ}$, so we drop it to linearize:</p>
<p>$$\begin{align*}R\proselabel{icp}{v} & \approx \proselabel{icp}{v}\cos\proselabel{icp}{θ} + (\proselabel{icp}{a}\times \proselabel{icp}{v})\sin\proselabel{icp}{θ} \\
     & = \cos\proselabel{icp}{θ} (\proselabel{icp}{v} + (\proselabel{icp}{ã}\times \proselabel{icp}{v}))\end{align*}\tag{8}\label{8}$$</p>
<p>where <span class='equation' code_block="icp">$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'ã', 'icp', 'def', false, '')", "id":"icp-ã", "sym":"ã", "func":"icp",  "localFunc":"", "type":"def", "case":"equation"} }{ {\mathit{ã}} } & = \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'a', 'icp', 'use', false, '')", "id":"icp-a", "sym":"a", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{a}} }tan\left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'θ', 'icp', 'use', false, '')", "id":"icp-θ", "sym":"θ", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{θ}} } \right)\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'icp', ['a', 'θ', 'ã'], false, []);"} }{}
\end{align*}
$</span> . Substituting into (6),<br />
$$\proselabel{icp}{\varepsilon_{symm}} \approx \sum_i \left( \cos \proselabel{icp}{θ}({\proselabel{icp}{{p}}}_i - {\proselabel{icp}{{q}}}_i)\cdot \proselabel{icp}{n_i} + \cos \proselabel{icp}{θ}(\proselabel{icp}{ã}\times ({\proselabel{icp}{{p}}}_i+{\proselabel{icp}{{q}}}_i))\cdot \proselabel{icp}{n}_i + {\proselabel{icp}{{t}}} \cdot \proselabel{icp}{n}_i \right)\notag$$<br />

        <div class='equation' code_block="icp">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$\\\\varepsilon_{symm}$', 'icp', 'def', false, '')", "id":"icp-$\\\\varepsilon_{symm}$", "sym":"$\\\\varepsilon_{symm}$", "func":"icp",  "localFunc":"", "type":"def", "case":"equation"} }{ {\varepsilon_{symm}} } & = \sum_{\mathit{i}} {cos\left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'θ', 'icp', 'use', false, '')", "id":"icp-θ", "sym":"θ", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{θ}} } \right)}^{2}{\left( \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'p', 'icp', 'use', false, '')", "id":"icp-p", "sym":"p", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{p}} }_{ \mathit{i} } - \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'q', 'icp', 'use', false, '')", "id":"icp-q", "sym":"q", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{q}} }_{ \mathit{i} } \right) \cdot \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'n', 'icp', 'use', false, '')", "id":"icp-n", "sym":"n", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{n}} }_{ \mathit{i} } + \left( \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'p', 'icp', 'use', false, '')", "id":"icp-p", "sym":"p", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{p}} }_{ \mathit{i} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'q', 'icp', 'use', false, '')", "id":"icp-q", "sym":"q", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{q}} }_{ \mathit{i} } \right) × \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'n', 'icp', 'use', false, '')", "id":"icp-n", "sym":"n", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{n}} }_{ \mathit{i} } \right) \cdot \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'ã', 'icp', 'use', false, '')", "id":"icp-ã", "sym":"ã", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{ã}} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'n', 'icp', 'use', false, '')", "id":"icp-n", "sym":"n", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{n}} }_{ \mathit{i} } \cdot \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't̃', 'icp', 'use', false, '')", "id":"icp-t̃", "sym":"t̃", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\textit{t̃}} } \right)}^{2}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'icp', ['t̃', 'q', 'n', 'ã', 'θ', 'p', '$\\\\varepsilon_{symm}$'], false, []);"} }{}
\end{align*}
\tag{9}\label{9}$$</div>
        <br />
where <span class='equation' code_block="icp">$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'n', 'icp', 'def', false, '')", "id":"icp-n", "sym":"n", "func":"icp",  "localFunc":"", "type":"def", "case":"equation"} }{ {\mathit{n}} }_{ \mathit{i} } & = \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$n_q$', 'icp', 'use', false, '')", "id":"icp-$n_q$", "sym":"$n_q$", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {n_q} }_{ \mathit{i} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$n_p$', 'icp', 'use', false, '')", "id":"icp-$n_p$", "sym":"$n_p$", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {n_p} }_{ \mathit{i} }\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'icp', ['$n_p$', '$n_q$', 'n'], false, []);"} }{}
\end{align*}
$</span> and <span class='equation' code_block="icp">$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't̃', 'icp', 'def', false, '')", "id":"icp-t̃", "sym":"t̃", "func":"icp",  "localFunc":"", "type":"def", "case":"equation"} }{ {\textit{t̃}} } & = \frac{\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't', 'icp', 'use', false, '')", "id":"icp-t", "sym":"t", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{t}} }}{cos\left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'θ', 'icp', 'use', false, '')", "id":"icp-θ", "sym":"θ", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{θ}} } \right)}\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'icp', ['t', 'θ', 't̃'], false, []);"} }{}
\end{align*}
$</span>. We now make the additional approximation of weighting the objective by $1/\cos^2 \proselabel{icp}{θ}$ , which approaches 1 for small $\proselabel{icp}{θ}$ . Finally, for better numerical stability, we normalize the $({\proselabel{icp}{{p}}}_i, {\proselabel{icp}{{q}}}_i)$ by translating each point set to the origin and adjusting the solved-for translation appropriately. This yields:</p>
<p>$$\sum_i \left[ (\proselabel{icp}{p̃}_i - \proselabel{icp}{q̃}_i)\cdot \proselabel{icp}{n}_i + ((\proselabel{icp}{p̃}_i + \proselabel{icp}{q̃}_i)\times \proselabel{icp}{n}_i) \cdot \proselabel{icp}{ã} + \proselabel{icp}{n}_i \cdot \proselabel{icp}{t̃} \right]^2\tag{10}\label{10}$$</p>
<p>where $p̃_i = {\proselabel{icp}{{p}}}_i − {\proselabel{icp}{{p}}}$ and $q̃_i = {\proselabel{icp}{{q}}}_i − {\proselabel{icp}{{q}}}$. This is a least-squares problem in $\proselabel{icp}{ã}$ and $\proselabel{icp}{t̃}$, and the final transformation from $P$ to $Q$ is:</p>
<p>$$trans({\proselabel{icp}{{q}}})\circ rot(\proselabel{icp}{θ}, \frac{\proselabel{icp}{a}}{||\proselabel{icp}{a}||}) \circ trans(\proselabel{icp}{t} \cos \proselabel{icp}{θ}) \circ rot(\proselabel{icp}{θ}, \frac{\proselabel{icp}{a}}{||\proselabel{icp}{a}||}) \circ trans(-{\proselabel{icp}{{p}}})
\tag{11}\label{11}$$</p>
<p>where $ {\proselabel{icp}{{θ}}} = tan^{−1} ||ã||$</p>
<p>Note that the new linearization results in the same system of equations as would the traditional approach. What changes is how the solved-for variables $\proselabel{icp}{ã}$ and $\proselabel{icp}{t̃}$ are interpreted. This produces a modest increase in accuracy but, more importantly, is necessary to obtain the property that the linearization is exact for exact correspondences (see Section 4.2). We may interpret (10) as a Gauss-Newton step applied to (6), using the Gibbs representation of rotations.</p>
<h1 id='theoretical-and-experimental-results'>4&nbsp;THEORETICAL AND EXPERIMENTAL RESULTS</h1><h2 id='the-symmetric-error-is-zero-when-corresponding-points-are-consistent-with-a-quadratic-surface'>4.1&nbsp;The Symmetric Error Is Zero When Corresponding Points Are Consistent With a Quadratic Surface</h2><p>Assume that points ${\proselabel{icp}{{p}}}$ and ${\proselabel{icp}{{q}}}$ are located on a height field $z = h(x,y)$ that may be approximated locally as second-order. We construct a coordinate system centered at their geodesic midpoint m, with the surface tangent to $xy$ (see Figure 3). The height of that surface relative to the tangent plane may be expressed as a quadratic function of $xy$ displacement away from $m$:<br />
$$\Delta z = \frac{1}{2}\begin{pmatrix}
\Delta x & \Delta y \\
\end{pmatrix} \begin{pmatrix}
e & f \\
f & g
\end{pmatrix}  \begin{pmatrix}
\Delta x \\
\Delta y
\end{pmatrix}\tag{12}\label{12}$$<br />
This is an even function, so if ${\proselabel{icp}{{p}}}$ and ${\proselabel{icp}{{q}}}$ are displaced by equal amounts in opposite directions from $m$, then their $z$ coordinates are equal, and ${\proselabel{icp}{{p}}} − {\proselabel{icp}{{q}}}$ is parallel to the $xy$ plane. Conversely, the perturbation of the surface normal away from $zˆ$ is an odd function:</p>
<p>$$\begin{pmatrix}
\Delta {\proselabel{icp}{{n}}}_x \\
\Delta {\proselabel{icp}{{n}}}_y
\end{pmatrix} = - \begin{pmatrix}
e & f \\
f & g
\end{pmatrix}  \begin{pmatrix}
\Delta x \\
\Delta y
\end{pmatrix}\tag{13}\label{13}$$</p>
<p>Therefore, ${\proselabel{icp}{{n_p}}} + {\proselabel{icp}{{n_q}}}$ is parallel to the $z$ axis, and so it must be perpendicular to ${\proselabel{icp}{{p}}} − {\proselabel{icp}{{q}}}$.<br />
Note that the property that the error vanishes near a second-order patch of surface does not hold for point-to-point, point-to-plane, or even the method of <a href="#ref19">Mitra et al. [2004]</a>. The latter, for example, considers a quadratic approximant to the square of the Euclidean distance function, which can be minimized only at a plane, line, or point. An objective function that vanishes near a curved surface, however, would require a higher-order approximation. This partially explains the faster convergence of $\proselabel{icp}{\varepsilon_{symm}}$, as observed in the experiments of Section 4.3.</p>
<p>Note also that, as ${\proselabel{icp}{{p}}}$ and ${\proselabel{icp}{{q}}}$ move away from being consistent with a second-order surface, the error in Equation $\ref{4}$ remains well-behaved: it is just linear in positions and normals. This is in contrast to the (squared) Euclidean distance function, whose Hessian diverges at the medial surface.</p>
<figure>
<img src="./img/icp-3.png" alt="Trulli" style="width:90%" class = "center">
<figcaption align = "center">Fig. 3. A second-order patch of surface around m, the geodesic midpoint between ${\proselabel{icp}{{p}}}$ and ${\proselabel{icp}{{q}}}$. Because the variation of height and normal relative to m are even and odd, respectively, ${\proselabel{icp}{{p}}} − {\proselabel{icp}{{q}}}$ and ${\proselabel{icp}{{n_p}}} + {\proselabel{icp}{{n_q}}}$ are parallel and perpendicular to the tangent plane at $m$, and so Equation $\ref{4}$ holds.</figcaption>
</figure>
<h2 id='the-linearization-is-exact-for-exact-correspondences'>4.2&nbsp;The Linearization is Exact for Exact Correspondences</h2><p>Unlike the traditional linearization of rotations, we observe that the linear least-squares problem in (10) produces an exact result when correspondences $({\proselabel{icp}{{p}}}_i, {\proselabel{icp}{{q}}}_i)$ are correct. This is because the approximation of $1/(\cos\proselabel{icp}{θ})^2$ as 1 involves a multiplicative factor that may be interpreted as a weight, and so the only additive term that is actually dropped contains a factor of $(\proselabel{icp}{p̃}_i − \proselabel{icp}{q̃}_i ) · \proselabel{icp}{a}$. However, if correspondences are correct and the points are center-of-mass normalized, then $\proselabel{icp}{p̃}_i − \proselabel{icp}{q̃}_i$ is guaranteed to be perpendicular to the rotation axis, and hence zero error is introduced by the linearization. We have verified experimentally that this is the case, up to roundoff error.</p>
<p>This an unexpected result, because previous techniques that solve for exact rotations have tended to involve nonlinear optimization, and hence require multiple iterations. There do exist several closed-form solutions for the minimization of $\proselabel{icp}{\varepsilon_{point}}$, but all are based on SVD or eigenvector problems <a href="#ref9">[Eggert et al. 1997]</a>. To the best of our knowledge, there are no published techniques that exactly optimize $\proselabel{icp}{\varepsilon_{plane}}$ or any related metric with a single linear solve, even for exact correspondences.</p>
<h2 id='proselabelicp-varepsilon_symm-accelerates-per-iteration-convergence'>4.3&nbsp;$\proselabel{icp}{  \varepsilon_{symm}  }$ Accelerates Per-Iteration Convergence</h2><p>In an ICP implementation, of course, correspondences will not be exact. Nevertheless, we observe that $\proselabel{icp}{\varepsilon_{symm}}$ produces faster convergence than $\proselabel{icp}{\varepsilon_{point}}$ and $\proselabel{icp}{\varepsilon_{plane}}$. We conduct an experiment in which we start with two copies of a mesh, then move one copy away from its ground-truth position and orientation. We execute a single iteration of ICP to align the shifted copy back towards the original. We measure error, both before and after that ICP iteration, as the root-mean-square distance between actual vertex positions and their ground-truth locations, where the mesh is scaled such that the root-mean-squared vertex distance from the center of mass is 1. No outlier rejection is performed.</p>
<p>We test a total of six objective functions, of which four are $\proselabel{icp}{\varepsilon_{point}}$, $\proselabel{icp}{\varepsilon_{plane}}$, $\proselabel{icp}{\varepsilon_{symm-RN}}$, and $\proselabel{icp}{\varepsilon_{symm}}$. The two additional objectives are:</p>
<ul>
<li>Quadratic: the method of <a href="#ref19">Mitra et al. [2004]</a> that minimizes a locally-quadratic approximant to the squared Euclidean distance function. The implementation uses the &ldquo;on demand&rdquo; method described in that paper, in which the approximation uses curvature information at the closest point.</li>
</ul>
<figure>
<img src="./img/icp-4.png" alt="Trulli" style="width:100%" class = "center">
<figcaption align = "center">Fig. 4. Left: Error decrease due to one ICP iteration on the dragon model, aligned to itself. Ground-truth errors before and after the ICP iteration are shown on the x and y axes, respectively, of this log-log plot. The proposed symmetric objective results in significantly faster decrease of error at each iteration. Center: Error decrease due to one iteration of ICP, aligning bun090 to bun000 (illustrated in blue and red, respectively, with the areas of overlap in purple). Right: Error decrease in one ICP iteration, aligning two scans from the TUM RGB-D dataset. Note the slower convergence because of the high level of noise.</figcaption>
</figure>
<ul>
<li>Two-plane: minimizing the sum of squared distances to planes defined by both ${\proselabel{icp}{{n_p}}}$ and ${\proselabel{icp}{{n_q}}}$ :<br />

        <div class='equation' code_block="icp">
        $$\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{align*}
\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$\\\\varepsilon_{two-plane}$', 'icp', 'def', false, '')", "id":"icp-$\\\\varepsilon_{two-plane}$", "sym":"$\\\\varepsilon_{two-plane}$", "func":"icp",  "localFunc":"", "type":"def", "case":"equation"} }{ {\varepsilon_{two-plane}} } & = \sum_{\mathit{i}} \left( {\left( \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'p', 'icp', 'use', false, '')", "id":"icp-p", "sym":"p", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{p}} }_{ \mathit{i} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }^{-1}\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'q', 'icp', 'use', false, '')", "id":"icp-q", "sym":"q", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{q}} }_{ \mathit{i} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't', 'icp', 'use', false, '')", "id":"icp-t", "sym":"t", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{t}} } \right) \cdot \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$n_p$', 'icp', 'use', false, '')", "id":"icp-$n_p$", "sym":"$n_p$", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {n_p} }_{ \mathit{i} } \right) \right)}^{2} + {\left( \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'p', 'icp', 'use', false, '')", "id":"icp-p", "sym":"p", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{p}} }_{ \mathit{i} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }^{-1}\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'q', 'icp', 'use', false, '')", "id":"icp-q", "sym":"q", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{q}} }_{ \mathit{i} } + \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 't', 'icp', 'use', false, '')", "id":"icp-t", "sym":"t", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{t}} } \right) \cdot \left( \idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, 'R', 'icp', 'use', false, '')", "id":"icp-R", "sym":"R", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {\mathit{R}} }^{-1}\idlabel{ {"onclick":"event.stopPropagation(); onClickSymbol(this, '$n_q$', 'icp', 'use', false, '')", "id":"icp-$n_q$", "sym":"$n_q$", "func":"icp",  "localFunc":"", "type":"use", "case":"equation"} }{ {n_q} }_{ \mathit{i} } \right) \right)}^{2} \right)\\\eqlabel{ {"onclick":"event.stopPropagation(); onClickEq(this, 'icp', ['q', 't', 'R', '$n_q$', '$n_p$', 'p', '$\\\\varepsilon_{two-plane}$'], false, []);"} }{}
\end{align*}
\tag{14}\label{14}$$</div>
        <br />
This approach is a symmetrized version (with split rotations) of methods previously used by <a href="#ref27">Tagliasacchi et al. [2015]</a> and <a href="#ref17">Luong et al. [2016]</a>, which in turn were related to the Hausdorff metric by <a href="#ref28">Tkach et al. [2016]</a>.</li>
</ul>
<p>Figure 4, left, shows the result of this experiment on the dragon model <a href="#ref6">[Curless and Levoy 1996]</a>. The graph compares the error after an iteration of alignment (plotted along the y axis) to error before alignment (x axis), for each method. Each datapoint represents the average over 1000 trials, each having a different starting transformation (that produces the same initial error).</p>
<p>We see that the behaviors of the different methods fall into three general categories. The point-to-point objective is the slowest: it reliably exhibits linear convergence. The point-to-plane, two-plane, and quadratic methods exhibit superlinear convergence, while the two symmetric objectives (whose curves lie essentially on top of each other) are even faster: they have a higher convergence order (greater slope of the curve) for large misalignment, and a similar convergence order but more favorable constant once alignment improves. Note that the graph is on a log-log scale, so the vertical distance between the curves can represent improvement by as much as an order of magnitude in per-iteration convergence.</p>
<p>Figure 4, center, shows a similar experiment, but for incomplete and partially-overlapping range scans (the bun000 and bun090 scans from the bunny model <a href="#ref29">[Turk and Levoy 1994]</a>). In this case, some form of robust estimation is necessary to account for partial overlap, and this may be done using techniques including explicit outlier rejection [<a href="#ref29">Turk and Levoy 1994</a>; <a href="#23">Pulli 1999</a>; <a href="#ref5">Chetverikov et al. 2005</a>], consistency conditions [<a href="#ref20">Pajdla and Van Gool 1995</a>; <a href="#ref8">Dorai et al. 1998</a>, M-estimation <a href="#ref11">[Fitzgibbon 2001]</a>, or sparsity-inducing norms <a href="#ref2">[Bouaziz et al. 2013]</a>. Because it is not our intention to exhaustively explore options for robust estimation, we adopt a relatively simple outlier-rejection strategy that excludes matches having normals with negative dot product, and pairs with (point-to-point) distance greater than 2.5 times the standard deviation of distances at each iteration <a href="#ref18">[Masuda et al. 1996]</a>. (The standard deviation is estimated robustly as 1.4826 times the median distance.) The relative ordering of the ICP variants is similar to the whole-model case, but the variants are closer to each other, due to noise and imperfect outlier rejection Ð these meshes only have an overlap (measured as intersection over union, or IOU) of approximately 23%.</p>
<p>Finally, Figure 4, right, shows the experimental convergence for a pair of scans of an indoor office environment, specifically timestamps 1305031104.030279 and 1305031108.503548 of the freiburg1_xyz sequence from the TUM RGB-D dataset <a href="#26">[Sturm et al. 2012]</a>. This dataset is qualitatively different from the bunny, since it contains many planar surfaces (which might be expected to boost the performance of Eplane and related variants), but also has some warp and scanning noise from the Kinect sensor (which leads to a nontrivial residual, decreasing the difference between variants). Even in this scenario, which might be expected to provide the least benefit to $\proselabel{icp}{\varepsilon_{symm}}$, the symmetric objective outperforms the others.</p>
<h2 id='icp-with-proselabelicpvarepsilon_symm-has-a-wide-convergence-basin'>4.4&nbsp;ICP with $\proselabel{icp}{\varepsilon_{symm}}$ Has a Wide Convergence Basin</h2><p>To measure how reliably the different ICP objectives reach the correct alignment, we repeatedly misalign two meshes by a given angle (about a random axis) and a given translation magnitude (in a random direction), then run ICP for a fixed number of iterations. For consistency, all variants sample points from both meshes, find closest points (according to Euclidean distance) on the other mesh, and use the outlier rejection strategies described above. The success of ICP is determined by whether points are within a threshold (1% of mesh size) of their ground-truth locations after alignment.</p>
<p>Figure 5 shows the convergence basin for the six ICP variants from the previous experiment, plus two variants that apply the Levenberg-Marquardt algorithm, either to $\proselabel{icp}{\varepsilon_{plane}}$ as in the work of <a href="#ref10">Fitzgibbon [2001]</a>, or to the new $\proselabel{icp}{\varepsilon_{symm}}$. Each small square shows the percentage of successful trials, averaged over all pairs of bunny scans having IOU overlap greater than 20%, and over 1000 initial transformations that have the given rotation angle and translation magnitude.</p>
<p>With 500 iterations, $\proselabel{icp}{\varepsilon_{point}}$ and $\proselabel{icp}{\varepsilon_{plane}}$ have regimes in which one is slightly better ($\proselabel{icp}{\varepsilon_{point}}$ for large translation and small rotation, and vice versa for $\proselabel{icp}{\varepsilon_{plane}}$). The quadratic method of <a href="#ref19">Mitra et al. [2004]</a> and Fitzgibbon’s LM-ICP (applied to Eplane) modestly improve convergence, with Esymm comparable to those two and Etwo-plane improving reliability even more. Levenberg-Marquardt applied to Esymm is both fast and reliable, achieving the widest convergence basin at 20 iterations and coming within a few percent of $\proselabel{icp}{\varepsilon_{two-plane}}$ at 500 iterations. The availability of a fast and reliable ICP variant is vital for real-time applications such as interactive 3D scanning <a href="#ref15">[Izadi et al. 2011]</a>, which have heretofore used point-to-plane ICP.</p>
<h1 id='discussion-and-future-work'>5&nbsp;DISCUSSION AND FUTURE WORK</h1><p>The symmetric objective represents a simple improvement to traditional point-to-plane ICP. At minimal additional implementation cost, it produces faster and more reliable convergence. Future work in this area consists of exploring the combination of the symmetric objective with modern approaches for denoising, surface descriptor matching, robust lp minimization, and step size control.</p>
<p>A further topic for future investigation is relating the symmetric objective to distance function minimization. Just as Equation $\ref{3}$ can be considered a linearization of the signed distance to Q evaluated at points on P, Equation $\ref{4}$ can be considered the linearization of the sum of that function, plus the signed distance to P evaluated at points on Q. While it might be possible to simplify this description (perhaps by considering samples at the midpoint between the two surfaces), even that does not readily lead to an explanation of the properties in Sections 3 and 4.1. Future analysis of the sum of distance transforms could lead to additional insights on Esymm.</p>
<h1 id='references'>6&nbsp;REFERENCES</h1><p id='ref0'>Dror Aiger, Niloy J. Mitra, and Daniel Cohen-Or. 2008. 4-Points Congruent Sets for Robust Pairwise Surface Registration. ACM Trans. Graph. 27, 3, Article 85 (Aug. 2008).</p>
<p id='ref1'>Paul J. Besl and Neil D. McKay. 1992. A Method for Registration of 3-D Shapes. IEEE Trans. PAMI 14, 2 (Feb. 1992), 239-256.</p>
<p id='ref2'>Sofien Bouaziz, Andrea Tagliasacchi, and Mark Pauly. 2013. Sparse Iterative Closest Point. In Proc. SGP.</p>
<p id='ref3'>Benedict Brown and Szymon Rusinkiewicz. 2007. Global Non-Rigid Alignment of 3-D Scans. ACM Trans. Graph. 26, 3, Article 21 (July 2007).</p>
<p id='ref4'>Yang Chen and Gérard Medioni. 1992. Object Modelling by Registration of Multiple Range Images. Image and Vision Computing 10, 3 (April 1992), 145-155.</p>
<p id='ref5'>Dmitry Chetverikov, Dmitry Stepanov, and Pavel Krsek. 2005. Robust Euclidean Align- ment of 3D Point Sets: The Trimmed Iterative Closest Point Algorithm. Image and Vision Computing 23, 3 (March 2005), 299-309.</p>
<p id='ref6'>Brian Curless and Marc Levoy. 1996. A Volumetric Method for Building Complex Models from Range Images. In Proc. SIGGRAPH.</p>
<p id='ref7'>Yago Díez, Ferran Roure, Xavier Lladó, and Joaquim Salvi. 2015. A Qualitative Review on 3D Coarse Registration Methods. ACM Comput. Surv. 47, 3, Article 45 (Feb. 2015). </p>
<p id='ref8'>Chitra Dorai, Gang Wang, Anil K. Jain, and Carolyn Mercer. 1998. Registration and Integration of Multiple Object Views for 3D Model Construction. IEEE Trans. PAMI 20, 1 (Jan. 1998), 83-89.</p>
<p id='ref9'>David W. Eggert, Adele Lorusso, and Robert B. Fisher. 1997. Estimating 3-D Rigid Body Transformations: A Comparison of Four Major Algorithms. Machine Vision and Applications 9, 5-6 (March 1997), 272-290.</p>
<p id='ref10'>Andrew W. Fitzgibbon. 2001. Robust Registration of 2D and 3D Point Sets. In Proc. BMVC.</p>
<p id='ref11'>Natasha Gelfand, Leslie Ikemoto, Szymon Rusinkiewicz, and Marc Levoy. 2003. Geometrically Stable Sampling for the ICP Algorithm. In Proc. 3DIM.</p>
<p id='ref12'>Natasha Gelfand, Niloy J. Mitra, Leonidas Guibas, and Helmut Pottmann. 2005. Robust Global Registration. In Proc. SGP.</p>
<p id='ref13'>Maciej Halber and Thomas Funkhouser. 2017. Fine-to-Coarse Global Registration of RGB-D Scans. In Proc. CVPR.</p>
<p id='ref14'>Daniel F. Huber and Martial Hebert. 2003. Fully Automatic Registration of Multiple 3D Data Sets. Image and Vision Computing 21, 7 (July 2003), 637-650.</p>
<p id='ref15'>Shahram Izadi, David Kim, Otmar Hilliges, David Molyneaux, Richard Newcombe, Pushmeet Kohli, Jamie Shotton, Steve Hodges, Dustin Freeman, Andrew Davison, and Andrew Fitzgibbon. 2011. KinectFusion: Real-time 3D Reconstruction and Interaction Using a Moving Depth Camera. In Proc. UIST.</p>
<p id='ref16'>Peter Kovesi. 2015. Good Colour Maps: How to Design Them. arXiv:1509.03700. Stefan Leopoldseder, Helmut Pottmann, and Hongkai Zhao. 2003. The d2-Tree: A Hierarchical Representation of the Squared Distance Function. Technical Report 101. Institute of Geometry, Vienna University of Technology.</p>
<p id='ref17'>Hiêp Quang Luong, Michiel Vlaminck, Werner Goeman, and Wilfried Philips. 2016. Consistent ICP for the Registration of Sparse and Inhomogeneous Point Clouds. In Proc. Int. Conf. on Communications and Electronics (ICCE).</p>
<p id='ref18'>Takeshi Masuda, Katsuhiko Sakaue, and Naokazu Yokoya. 1996. Registration and Integration of Multiple Range Images for 3-D Model Construction. In Proc. ICPR. </p>
<p id='ref19'>Niloy J. Mitra, Natasha Gelfand, Helmut Pottmann, and Leonidas Guibas. 2004. Registration of Point Cloud Data from a Geometric Optimization Perspective. In Proc. SGP.</p>
<p id='ref20'>Tomáš Pajdla and Luc Van Gool. 1995. Matching of 3-D Curves Using Semi-Differential Invariants. In Proc. ICCV.</p>
<p id='ref21'>Fran cois Pomerleau, Francis Colas, and Roland Siegwart. 2015. A Review of Point Cloud Registration Algorithms for Mobile Robotics. Foundations and Trends in Robotics 4, 1 (May 2015), 1-104.</p>
<p id='ref22'>Helmut Pottmann, Qi-Xing Huang, Yong-Liang Yang, and Shi-Min Hu. 2006. Geometry and Convergence Analysis of Algorithms for Registration of 3D Shapes. IJCV 67, 3 (May 2006), 277-296.</p>
<p id='ref23'>Kari Pulli. 1999. Multiview Registration for Large Data Sets. In Proc. 3DIM.</p>
<p id='ref24'>Szymon Rusinkiewicz and Marc Levoy. 2001. Efficient Variants of the ICP Algorithm. In Proc. 3DIM.</p>
<p id='ref25'>Aleksandr V. Segal, Dirk Haehnel, and Sebastian Thrun. 2009. Generalized-ICP. In Proc. RSS.</p>
<p id='ref26'>Jürgen Sturm, Nikolas Engelhard, Felix Endres, Wolfram Burgard, and Daniel Cremers. 2012. A Benchmark for the Evaluation of RGB-D SLAM Systems. In Proc. IROS. </p>
<p id='ref27'>Andrea Tagliasacchi, Matthias Schroeder, Anastasia Tkach, Sofien Bouaziz, Mario Botsch, and Mark Pauly. 2015. Robust Articulated-ICP for Real-Time Hand Tracking. In Proc. SGP.</p>
<p id='ref28'>Anastasia Tkach, Mark Pauly, and Andrea Tagliasacchi. 2016. Sphere-Meshes for Real-Time Hand Modeling and Tracking. ACM Trans. Graph. 35, 6, Article 222 (Nov. 2016).</p>
<p id='ref29'>Greg Turk and Marc Levoy. 1994. Zippered Polygon Meshes from Range Images. In Proc. SIGGRAPH.</p>
<p id='ref30'>Jiaolong Yang, Hongdong Li, Dylan Campbell, and Yunde Jia. 2016. Go-ICP: A Globally Optimal Solution to 3D ICP Point-Set Registration. IEEE Trans. PAMI 38, 11 (Nov. 2016), 2241-2254.</p>
</body>
</html>