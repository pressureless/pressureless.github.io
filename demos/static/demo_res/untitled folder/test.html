<!DOCTYPE html>
<html>
<head>
	<link href="prism.css" rel="stylesheet" />
</head>
<body>
	<script src="prism.js"></script>
	Reference: <a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">polygon mesh processing</a>, Page 10  <br>

	Here is the description: <br>
	<img src="tt.png" alt="Girl in a jacket" width="500" height="600"><br>


	Here is the LA code: <br>
	<div class="panel-body" style=' height: 500px;overflow:auto; width:900px;'><pre ><code class="language-psython">"""
		given
p_i: ℝ^3: points on lines
d_i: ℝ^3: unit directions along lines

k_i = (p_i - (p_i⋅d_i)d_i)
a_i = [1,0,0]^T - d_i,0 d_i
b_i = [0,1,0]^T - d_i,1 d_i
c_i = [0,0,1]^T - d_i,2 d_i

 
M = [ (∑_i( a_i,0 - d_i,0 (d_i⋅a_i) ))    (∑_i( a_i,1 - d_i,1 (d_i⋅a_i) ))    (∑_i( a_i,2 - d_i,2 (d_i⋅a_i) ))
      (∑_i( b_i,0 - d_i,0 (d_i⋅b_i) ))    (∑_i( b_i,1 - d_i,1 (d_i⋅b_i) ))    (∑_i( b_i,2 - d_i,2 (d_i⋅b_i) ))
      (∑_i( c_i,0 - d_i,0 (d_i⋅c_i) ))    (∑_i( c_i,1 - d_i,1 (d_i⋅c_i) ))    (∑_i( c_i,2 - d_i,2 (d_i⋅c_i) )) ]

r = [ ∑_i( k_i⋅a_i )
      ∑_i( k_i⋅b_i )
      ∑_i( k_i⋅c_i ) ]

q = M^(-1) r
 </code></pre></div>
    </div>


	Here is the Python output: <br>
	<div class="panel-body" style=' height: 500px;overflow:auto; width:900px;'><pre ><code class="language-python">"""
given
p_i: ℝ^3: points on lines
d_i: ℝ^3: unit directions along lines

k_i = (p_i - (p_i⋅d_i)d_i)
a_i = [1,0,0]^T - d_i,0 d_i
b_i = [0,1,0]^T - d_i,1 d_i
c_i = [0,0,1]^T - d_i,2 d_i

 
M = [ (∑_i( a_i,0 - d_i,0 (d_i⋅a_i) ))    (∑_i( a_i,1 - d_i,1 (d_i⋅a_i) ))    (∑_i( a_i,2 - d_i,2 (d_i⋅a_i) ))
      (∑_i( b_i,0 - d_i,0 (d_i⋅b_i) ))    (∑_i( b_i,1 - d_i,1 (d_i⋅b_i) ))    (∑_i( b_i,2 - d_i,2 (d_i⋅b_i) ))
      (∑_i( c_i,0 - d_i,0 (d_i⋅c_i) ))    (∑_i( c_i,1 - d_i,1 (d_i⋅c_i) ))    (∑_i( c_i,2 - d_i,2 (d_i⋅c_i) )) ]

r = [ ∑_i( k_i⋅a_i )
      ∑_i( k_i⋅b_i )
      ∑_i( k_i⋅c_i ) ]

q = M^(-1) r


"""
import numpy as np
import scipy
import scipy.linalg
from scipy import sparse
from scipy.integrate import quad
from scipy.optimize import minimize


def myExpression(p, d):
    """
    :param :p : ℝ^3: points on lines
    :param :d : ℝ^3: unit directions along lines
    """
    p = np.asarray(p, dtype=np.float64)
    d = np.asarray(d, dtype=np.float64) 
 </code></pre></div>
 Here is the Eigen output: <br>
 <div class="panel-body" style=' height: 500px;overflow:auto; width:900px;'><pre ><code class="language-cpp">
#include <Eigen/Core>
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <iostream>
#include <set>

/**
 * myExpression
 *
 * @param p  ℝ^3: points on lines
 * @param d  ℝ^3: unit directions along lines
 * @return q
 */
Eigen::Matrix<double, 3, 1> myExpression(
    const std::vector<Eigen::Matrix<double, 3, 1>> & p,
    const std::vector<Eigen::Matrix<double, 3, 1>> & d)
{
}
 </code></pre></div>

 Here is the Tex output: <br>

 <div class="panel-body" style=' height: 500px; overflow:auto; width:900px;'><pre ><code class="language-tex">
\documentclass[12pt]{article}
\usepackage{mathdots}
\usepackage[bb=boondox]{mathalfa}
\usepackage{mathtools}
\usepackage{amssymb}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{document}

given
\begin{itemize}
\item $p_{i} \in \mathbb{R}^{ 3}:$points on lines
\item $d_{i} \in \mathbb{R}^{ 3}:$unit directions along lines
\item $A \in \mathbb{R}^{ 3 \times 3 }:$unit directions along lines
\end{itemize}

\[
\sum_i (8 \cdot A_{i, *})
\]

\end{document}

 	</code></pre></div>

	Here is the pdf result: <br>
	<img src="la.pdf" alt="Girl in a jacket" width="500" height="600"><br>

</body>
</html>